#-----------------------------------------------------------
# Vivado v2016.4 (64-bit)
# SW Build 1756540 on Mon Jan 23 19:11:19 MST 2017
# IP Build 1755317 on Mon Jan 23 20:30:07 MST 2017
# Start of session at: Wed Oct 24 10:48:35 2018
# Process ID: 31092
# Current directory: /usr/local/src/floorplan
# Command line: vivado
# Log file: /usr/local/src/floorplan/vivado.log
# Journal file: /usr/local/src/floorplan/vivado.jou
#-----------------------------------------------------------
start_gui
ls
WARNING: [Common 17-259] Unknown Tcl command 'ls' sending command to the OS shell for execution. It is recommended to use 'exec' to send the command to the OS shell.
engine
model.cpp
paper
rand.cpp
README.md
reqs.csv
simulator
vivado.jou
vivado.log
vivado_pid31092.str
cd ../xilinx/home/holmes/xilinx/xilinx_16/verilog_projects/partial_reconf_16/prc_7s/
ls
WARNING: [Common 17-259] Unknown Tcl command 'ls' sending command to the OS shell for execution. It is recommended to use 'exec' to send the command to the OS shell.
Bitstreams
Checkpoint
command.log
command_partial_flow.log
command_prev.log
create_prom_file_kc705.tcl
create_prom_file_vc707.tcl
create_prom_file_vc709.tcl
critical.log
critical_prev.log
design.tcl
fsm_encoding.os
hd_visual
Implement
prc_bitstream_sizes_2016.3.xlsx
pr_verify_results.log
README.txt
run.log
run_prev.log
Sources
Synth
Tcl_HD
usage_statistics_webtalk.html
usage_statistics_webtalk.xml
vivado.jou
vivado.log
vivado_pid29723.debug
vivado_pid29723.str
source design.tc
couldn't read file "design.tc": no such file or directory
source design.tcl
# set tclParams [list hd.visual 1 hd.routingContainmentAreaExpansion false] 
# if {[file exists "./Tcl_HD"]} { 
#    set tclDir  "./Tcl_HD"
# } else {
#    error "ERROR: No valid location found for required Tcl scripts. Set \$tclDir in design.tcl to a valid location."
# }
# puts "Setting TCL dir to $tclDir"
Setting TCL dir to ./Tcl_HD
# source $tclDir/design_utils.tcl
## set modules             [list ]
## set implementations     [list ]
## set opt_directives   [list Explore                \
##                            ExploreArea            \
##                            AddRemap               \
##                            ExploreSequentialArea  \
##                            RuntimeOptimized       \
##                            NoBramPowerOpt         \
##                            Default                \
##                      ]
## set place_directives [list Explore                \
##                            WLDrivenBlockPlacement \
##                            AltWLDrivenPlacement   \
##                            LateBlockPlacement     \
##                            ExtraNetDelay_high     \
##                            ExtraNetDelay_medium   \
##                            ExtraNetDelay_low      \
##                            SpreadLogic_high       \
##                            SpreadLogic_medium     \
##                            SpreadLogic_low        \
##                            ExtraPostPlacementOpt  \
##                            SSI_ExtraTimingOpt     \
##                            SSI_SpreadSLLs         \
##                            SSI_BalanceSLLs        \
##                            SSI_BalanceSLRs        \
##                            SSI_HighUtilSLRs       \
##                            RuntimeOptimized       \
##                            Quick                  \
##                            Default                \
##                      ]
## set phys_directives  [list Explore                \
##                            ExploreWithHoldFix     \
##                            AggressiveExplore      \
##                            AlternateReplication   \
##                            AggressiveFanoutOpt    \
##                            AlternateDelayModeling \
##                            AddRetime              \
##                            AlternateFlowWithRetiming \
##                            Default                \
##                      ]
## set route_directives [list Explore                \
##                            NoTimingRelaxation     \
##                            MoreGlobalIterations   \
##                            HigherDelayCost        \
##                            AdvancedSkewModeling   \
##                            RuntimeOptimized       \
##                            Quick                  \
##                            Default                \
##                       ]
## array set module_attributes [list "moduleName"           [list string   null]  \
##                                   "top_level"            [list boolean {0 1}]  \
##                                   "prj"                  [list string   null]  \
##                                   "includes"             [list string   null]  \
##                                   "generics"             [list string   null]  \
##                                   "vlog_headers"         [list string   null]  \
##                                   "vlog_defines"         [list string   null]  \
##                                   "sysvlog"              [list string   null]  \
##                                   "vlog"                 [list string   null]  \
##                                   "vhdl"                 [list string   null]  \
##                                   "ip"                   [list string   null]  \
##                                   "ipRepo"               [list string   null]  \
##                                   "bd"                   [list string   null]  \
##                                   "cores"                [list string   null]  \
##                                   "xdc"                  [list string   null]  \
##                                   "synthXDC"             [list string   null]  \
##                                   "implXDC"              [list string   null]  \
##                                   "synth"                [list boolean {0 1}]  \
##                                   "synth_options"        [list string   null]  \
##                                   "synthCheckpoint"      [list string   null]  \
##                             ]
## array set impl_attributes   [list "top"                        [list string   null]  \
##                                   "name"                       [list string   null]  \
##                                   "implXDC"                    [list string   null]  \
##                                   "cores"                      [list string   null]  \
##                                   "ip"                         [list string   null]  \
##                                   "ipRepo"                     [list string   null]  \
##                                   "impl"                       [list boolean {0 1}]  \
##                                   "hd.impl"                    [list boolean {0 1}]  \
##                                   "pr.impl"                    [list boolean {0 1}]  \
##                                   "ic.impl"                    [list boolean {0 1}]  \
##                                   "hd.budget"                  [list boolean {0 1}]  \
##                                   "hd.budget_exclude"          [list string   null]  \
##                                   "partitions"                 [list string   null   \
##                                                                   string   null   \
##                                                                   enum    {implement import greybox}  \
##                                                                   string   null   \
##                                                                   enum    {default ooc iso}           \
##                                                                   enum    {logical placement routing} \
##                                                                   string   null   \
##                                                                ] \
##                                   "link"                       [list boolean {0 1}]  \
##                                   "opt"                        [list boolean {0 1}]  \
##                                   "opt.pre"                    [list string   null]  \
##                                   "opt_options"                [list string   null]  \
##                                   "opt_directive"              [list enum     $opt_directives]   \
##                                   "place"                      [list boolean {0 1}]  \
##                                   "place.pre"                  [list string   null]  \
##                                   "place_options"              [list string   null]  \
##                                   "place_directive"            [list enum     $place_directives] \
##                                   "phys"                       [list boolean {0 1}]  \
##                                   "phys.pre"                   [list string   null]  \
##                                   "phys_options"               [list string   null]  \
##                                   "phys_directive"             [list enum     $phys_directives]  \
##                                   "route"                      [list boolean {0 1}]  \
##                                   "route.pre"                  [list string   null]  \
##                                   "route_options"              [list string   null]  \
##                                   "route_directive"            [list enum     $route_directives] \
##                                   "post_phys"                  [list boolean {0 1}]  \
##                                   "post_phys.pre"              [list string   null]  \
##                                   "post_phys_options"          [list string   null]  \
##                                   "post_phys_directive"        [list enum     $phys_directives]  \
##                                   "verify"                     [list boolean {0 1}]  \
##                                   "bitstream"                  [list boolean {0 1}]  \
##                                   "bitstream.pre"              [list string   null]  \
##                                   "bitstream_options"          [list string   null]  \
##                                   "bitstream_settings"         [list string   null]  \
##                                   "partial_bitstream_options"  [list string   null]  \
##                                   "partial_bitstream_settings" [list string   null]  \
##                                   "cfgmem.icap"                [list boolean {0 1}]  \
##                                   "cfgmem.pcap"                [list boolean {0 1}]  \
##                                   "cfgmem.offset"              [list string   null]  \
##                                   "cfgmem.size"                [list enum    {1 2 4 8 16 32 64 128 256 512}] \
##                                   "cfgmem.interface"           [list enum    {SMAPx8 SMAPx16 SMAPx32}] \
##                                   "drc.quiet"                  [list boolean {0 1}]  \
##                             ]
## proc add_implementation { name } {
##    global implementations
##    set procname [lindex [info level 0] 0]
##    
##    if {[lsearch -exact $implementations $name] >= 0} {
##       set errMsg "\nERROR: Implementation $name is already defined"
##       error $errMsg
##    }
## 
##    lappend implementations $name
##    set_attribute impl $name "top"                         ""
##    set_attribute impl $name "name"                        $name
##    set_attribute impl $name "implXDC"                     "" 
##    set_attribute impl $name "cores"                       ""
##    set_attribute impl $name "ip"                          ""
##    set_attribute impl $name "ipRepo"                      ""
##    set_attribute impl $name "impl"                        0
##    set_attribute impl $name "hd.impl"                     0
##    set_attribute impl $name "pr.impl"                     0
##    set_attribute impl $name "ic.impl"                     0
##    set_attribute impl $name "hd.budget"                   1
##    set_attribute impl $name "hd.budget_exclude"           ""
##    set_attribute impl $name "link"                        1
##    set_attribute impl $name "partitions"                  ""
##    set_attribute impl $name "opt"                         1
##    set_attribute impl $name "opt.pre"                     ""
##    set_attribute impl $name "opt_options"                 ""
##    set_attribute impl $name "opt_directive"               ""
##    set_attribute impl $name "place"                       1
##    set_attribute impl $name "place.pre"                   ""
##    set_attribute impl $name "place_options"               ""
##    set_attribute impl $name "place_directive"             ""
##    set_attribute impl $name "phys"                        1
##    set_attribute impl $name "phys.pre"                    ""
##    set_attribute impl $name "phys_options"                ""
##    set_attribute impl $name "phys_directive"              ""
##    set_attribute impl $name "route"                       1
##    set_attribute impl $name "route.pre"                   ""
##    set_attribute impl $name "route_options"               ""
##    set_attribute impl $name "route_directive"             ""
##    set_attribute impl $name "post_phys"                   0
##    set_attribute impl $name "post_phys.pre"               ""
##    set_attribute impl $name "post_phys_options"           ""
##    set_attribute impl $name "post_phys_directive"         ""
##    set_attribute impl $name "verify"                      0
##    set_attribute impl $name "bitstream"                   0
##    set_attribute impl $name "bitstream.pre"               ""
##    set_attribute impl $name "bitstream_options"           ""
##    set_attribute impl $name "bitstream_settings"          ""
##    set_attribute impl $name "partial_bitstream_options"   ""
##    set_attribute impl $name "partial_bitstream_settings"  ""
##    set_attribute impl $name "cfgmem.icap"                 0
##    set_attribute impl $name "cfgmem.pcap"                 0
##    set_attribute impl $name "cfgmem.offset"               "up 0x0"
##    set_attribute impl $name "cfgmem.size"                 "1"
##    set_attribute impl $name "cfgmem.interface"            "SMAPx32"
##    set_attribute impl $name "drc.quiet"                   0
## }
## proc add_module { name } {
##    global modules synthDir
## 
##    if {[lsearch -exact $modules $name] >= 0} {
##       set errMsg "\nERROR: Module $name is already defined"
##       error $errMsg
##    }
## 
##    lappend modules $name
##    set_attribute module $name "moduleName"       $name
##    set_attribute module $name "top_level"        0
##    set_attribute module $name "prj"              ""
##    set_attribute module $name "includes"         ""
##    set_attribute module $name "generics"         ""
##    set_attribute module $name "vlog_headers"     [list ]
##    set_attribute module $name "vlog_defines"     ""
##    set_attribute module $name "sysvlog"          [list ]
##    set_attribute module $name "vlog"             [list ]
##    set_attribute module $name "vhdl"             [list ]
##    set_attribute module $name "ip"               [list ]
##    set_attribute module $name "ipRepo"           [list ]
##    set_attribute module $name "bd"               [list ]
##    set_attribute module $name "cores"            [list ]
##    set_attribute module $name "xdc"              [list ]
##    set_attribute module $name "synthXDC"         [list ]
##    set_attribute module $name "implXDC"          [list ]
##    set_attribute module $name "synth"            0 
##    set_attribute module $name "synth_options"    "-flatten_hierarchy rebuilt" 
##    set_attribute module $name "synthCheckpoint"  ""
## }
## proc set_attribute { type name attribute {values null} } {
##    global ${type}Attribute
##    set procname [lindex [info level 0] 0]
## 
##    switch -exact -- $type {
##       module  {set list_type "modules"}
##       impl    {set list_type "implementations"}
##       default {error "\nERROR: Invalid type \'$type\' specified"}
##    }
## 
##    check_list $list_type $name $procname
##    check_attribute $type $attribute $procname
##    if {![string match $values "null"]} {
##       foreach value $values {
##          check_attribute_value $type $attribute $value
##       }
##       set ${type}Attribute(${name}.$attribute) $values
##    } else {
##       puts "Critical Warning: Attribute $attribute for $type $name is set to $values. The value will not be modified."
##    }
##    return $values
## }
## proc get_attribute { type name attribute } {
##    global ${type}Attribute
##    set procname [lindex [info level 0] 0]
## 
##    switch -exact -- $type {
##       module  {set list_type "modules"}
##       impl    {set list_type "implementations"}
##       default {error "\nERROR: Invalid type \'$type\' specified"}
##    }
## 
##    check_list $list_type $name $procname
##    check_attribute $type $attribute $procname
##    return [subst -nobackslash \$${type}Attribute(${name}.$attribute)]
## }
## proc check_attribute { type attribute procname } {
##    global ${type}_attributes
##    set attributes [array names ${type}_attributes]
##    if {[lsearch -exact $attributes $attribute] < 0} {
##       set errMsg "\nERROR: Invalid $type attribute \'$attribute\' specified in $procname"
##       error $errMsg
##    }
## }
## proc check_attribute_value { type attribute values } {
##    global ${type}_attributes 
##    if {[info exists ${type}_attributes($attribute)]} {
##       set attribute_checks [subst -nobackslashes \$${type}_attributes($attribute)]
##       set index 0
##       foreach {attr_type attr_values} $attribute_checks {
##          set value [lindex $values $index]
##          if {![string match $attr_values "null"] && [llength $value]} {
##             set pass 0
##             foreach attr_value $attr_values {
##                if {$attr_value==$value} {
##                   set pass 1
##                }
##             }
##             if {$pass==0} {
##                set errMsg "\nERROR: Value \'$value\' of $type attribute $attribute of type $attr_type is not valid.\n"
##                append errMsg "Supported values are: $attr_values"
##                error $errMsg
##             }
##          }
##          incr index
##       }
##    } else {
##       set errMsg "\nERROR: Could not find attribute $attribute in array ${type}_attributes."
##       error $errMsg
##    }
## }
## proc check_list { list_type name procname } {
##    global [subst $list_type]
##    if {[lsearch -exact [subst -nobackslash \$$list_type] $name] < 0} {
##       set errMsg "\nERROR: Invalid $list_type \'$name\' specified in $procname"
##       error $errMsg 
##    }
## }
## proc set_directives {$type $name} {
##    global Directives
##      
##    set_attribute $type $name opt_directive   $Directives(opt)
##    set_attribute $type $name place_directive $Directives(place)
##    set_attribute $type $name phys_directive  $Directives(phys)
##    set_attribute $type $name route_directive $Directives(route)
## }
## proc list_runs { } {
##    #### Print list of Modules
##    if {[llength [get_modules synth]]} {
##       set table "-title {#HD: List of modules to be synthesized}"
##       append table " -row {Module \"Module Name\" \"Top Level\" Options}"
##       foreach module [get_modules synth] {
##          set moduleName [get_attribute module $module moduleName] 
##          set top [get_attribute module $module top_level]
##          set synth_options [get_attribute module $module synth_options]
##          append table " -row {$module $moduleName $top \"$synth_options\"}"
##       }
##       print_table $table 
##    } else {
##       puts "#HD: No modules set to be synthesized"
##    }
##    if {[llength [get_modules !synth]]} {
##       puts "#HD: Defined modules not being synthesized:"
##       set count 1
##       foreach module [get_modules !synth] {
##          puts "\t$count. $module ([get_attribute module $module moduleName])"
##          incr count
##       }
##    }
## 
##    #### Print list of Configurations
##    if {[llength [get_implementations "pr.impl impl" &&]]} {
##       set configs [sort_configurations [get_implementations "pr.impl impl" &&]]
##       set table "-title {#HD: List of Configurations to be implemented}"
##       append table " -row {Configuration \"Reconfig Modules\" \"Static State\" pr_verify write_bistream}"
##       #Sort list of configurations. Insert "initial" config at beginning of list.
##       foreach configuration $configs { 
##          set partitions [get_attribute impl $configuration partitions]
##          set top        [get_attribute impl $configuration top]
##          set verify     [get_attribute impl $configuration verify]
##          set bitstream  [get_attribute impl $configuration bitstream]
##          set RMs ""
##          set staticState ""
##          foreach partition $partitions {
##             lassign $partition module cell state name type level dcp
##             if {![string match $cell $top]} {
##                if {[string match $state "greybox"]} {
##                   lappend RMs "$state"
##                } else {
##                   lappend RMs "$module\($state\)"
##                }
##             } else {
##                set staticState $state
##             }
##          }
##          set rmCount [llength $RMs]
##          for {set i 0} {$i < $rmCount} {incr i} {
##             if {$i==0} {
##                append table " -row {$configuration [lindex $RMs $i] $staticState $verify $bitstream}"
##             } else {
##                append table " -row {\"\" [lindex $RMs $i] \"\" \"\" \"\"}"
##             } 
##          }
##       }
##       print_table $table 
##    } else {
##       puts "#HD: No Configurations set to be implemented"
##    }
##    if {[llength [get_implementations "pr.impl !impl" &&]]} {
##       puts "#HD: Defined Configurations not being implemented:"
##       set count 1
##       foreach config [get_implementations "pr.impl !impl" &&] {
##          puts "\t$count. $config"
##          incr count
##       }
##    }
## 
##    #### Print list of Implementations
##    if {[llength [get_implementations "!pr.impl impl" &&]]} {
##       set table "-title {#HD: List of Implementations to be implemented}"
##       append table " -row {Implementation Top Partitions \"Flow Type\" write_bistream}"
##       foreach impl [get_implementations "!pr.impl impl" &&] {
##          set partitions [get_attribute impl $impl partitions]
##          set top        [get_attribute impl $impl top]
##          set hd         [get_attribute impl $impl hd.impl]
##          set ic         [get_attribute impl $impl ic.impl]
##          set bitstream  [get_attribute impl $impl bitstream]
## 
##          if {$hd} {
##             set runType "Hierarchical"
##          } elseif {$ic} {
##             set runType "In-Context"
##          } else {
##             set runType "Flat"
##          }
## 
##          set hdCells "" 
##          set state ""
##          set topState "implement"
##          foreach partition $partitions {
##             lassign $partition module cell state name type level dcp
##             if {![string match $cell $top]} {
##                if {![llength $name]} {
##                   set name [lindex [split $cell "/"] end]
##                }
##                lappend hdCells "$name\($state\)"
##             } else {
##                set topState $state
##             }
##          }
## 
##          if {[llength $hdCells]} {
##             for {set i 0} {$i < [llength $hdCells]} {incr i} {
##                if {$i==0} {
##                   append table " -row {$impl $top\($topState\) [lindex $hdCells $i] $runType $bitstream}"
##                } else {
##                   append table " -row {\"\" \"\"  [lindex $hdCells $i] \"\" \"\"}"
##                } 
##             }
##          } else {
##             append table " -row {$impl $top\($topState\) \"\" $runType $bitstream}"
##          }
##       }
##       print_table $table 
##    }
##    if {[llength [get_implementations "!pr.impl !impl" &&]]} {
##       puts "#HD: Defined Implementations not being implemented:"
##       set count 1
##       foreach impl [get_implementations "!pr.impl !impl" &&] {
##          puts "\t$count. $impl"
##          incr count
##       }
##    }
##    puts "\n"
## }
## proc sort_configurations { configurations } {
##    set configs "" 
##    #Sort list of configurations. Insert "initial" config at beginning of list.
##    foreach configuration $configurations {
##       set partitions [get_attribute impl $configuration partitions]
##       set top        [get_attribute impl $configuration top]
##       foreach partition $partitions {
##          lassign $partition module cell state name type level dcp
##          if {[string match $cell $top]} {
##             if {[string match -nocase $state "implement"]} {
##                set configs [linsert $configs 0 $configuration]
##             } else {
##                lappend configs $configuration
##             }
##          }
##       }
##    }
## 
##    #Make sure no configurations get lost in the sort
##    if {[llength $configs] == [llength $configurations]} {
##       return $configs
##    } else {
##       set errMsg "\nERROR: Number of configurations changed during sorting process." 
##       error $errMsg
##    }
## }
## proc set_parameters {params} {
##    command "puts \"\t#HD: Setting Tcl Params:\""
##    foreach {name value} $params   {
##       puts "\t$name == $value"
##       command "set_param $name $value"
##    }
##    puts "\n"
## }
## proc report_attributes { type name } {
##    global ${type}Attribute
##    global ${type}_attributes
##    set procname [lindex [info level 0] 0]
##    set widthCol1 18
##    set widthCol2 90
## 
##    switch -exact -- $type {
##       module  {set list_type "modules"}
##       impl    {set list_type "implementations"}
##       default {error "\nERROR: Invalid type \'$type\' specified"}
##    }
## 
##    check_list $list_type $name $procname
##    puts "Report $type properties for $name:"
##    puts "| [string repeat - $widthCol1] | [string repeat - $widthCol2] |"
##    puts [format "| %-*s | %-*s |" $widthCol1 "Attribute" $widthCol2 "Value"]
##    puts "| [string repeat - $widthCol1] | [string repeat - $widthCol2] |"
##    foreach {attribute } [lsort [array names ${type}_attributes]] {
##       set value [subst -nobackslash \$${type}Attribute(${name}.$attribute)]
##       puts [format "| %-*s | %-*s |" $widthCol1 $attribute $widthCol2 $value]
##    }
##    puts "| [string repeat - $widthCol1] | [string repeat - $widthCol2] |"
## }
## proc get_configurations { } {
##    set configurations [get_implementations pr.impl]
##    return $configurations
## }
## proc get_hd_implementations { } {
##    set implementations [get_implementations hd.impl]
##    return $implementations
## }
## proc get_modules { {filters ""} {function &&} } {
##    upvar #0 modules modules
## 
##    if {[llength $filters]} {
##       set filtered_modules ""
##       foreach module $modules {
##          foreach filter $filters {
##             #Check if value is "not", and remove ! from name
##             if {[regexp {!(.*)} $filter old filter]} {
##                set value 0
##             } else {
##                set value 1
##             }
##             if {[get_attribute module $module $filter] == $value} {
##                set match 1
##                if {[string match $function "||"]} {
##                   #Add matching filter results if not already added
##                   if {[lsearch -exact $filtered_modules $module] < 0} {
##                      lappend filtered_modules $module
##                      break
##                   }
##                }
##             } else {
##                set match 0
##                if {[string match $function "&&"]} {
##                   break
##                }
##             }
##          }
##          if {$match && [string match $function "&&"]} {
##             #Add matching filter results if not already added
##             if {[lsearch -exact $filtered_modules $module] < 0} {
##                lappend filtered_modules $module
##             }
##          }
##       }
##       return $filtered_modules
##    } else {
##       return $modules
##    }
## }
## proc get_implementations { {filters ""} {function &&} } {
##    upvar #0 implementations implementations
## 
##    if {[llength $filters]} {
##       set filtered_implementations ""
##       foreach implementation $implementations {
##          foreach filter $filters {
##             #Check if value is "not", and remove ! from name
##             if {[regexp {!(.*)} $filter old filter]} {
##                set value 0
##             } else {
##                set value 1
##             }
##             if {[get_attribute impl $implementation $filter] == $value} {
##                set match 1
##                if {[string match $function "||"]} {
##                   #Add matching filter results if not already added
##                   if {[lsearch -exact $filtered_implementations $implementation] < 0} {
##                      lappend filtered_implementations $implementation
##                      break
##                   }
##                }
##             } else {
##                set match 0
##                if {[string match $function "&&"]} {
##                   break
##                }
##             }
##          }
##          if {$match && [string match $function "&&"]} {
##             #Add matching filter results if not already added
##             if {[lsearch -exact $filtered_implementations $implementation] < 0} {
##                lappend filtered_implementations $implementation
##             }
##          }
##       }
##       return $filtered_implementations
##    } else {
##       return $implementations
##    }
## }
## proc check_part {part} {
##    set device [lindex [split $part -] 0]
##    if {![llength [get_parts $part]]} {
##       puts "ERROR: No valid part found matching specifiec part:\n\t$part"
##       if {[llength [get_parts ${device}*]]} {
##          puts "Valid part combinations for $device:"
##          puts "\t[join [get_parts ${device}*] \n\t]"
##       }
##       error "ERROR: Check value of specified part."
##    } else {
##       puts "INFO: Found part matching $part"
##    }
## }
# source $tclDir/log_utils.tcl
## if {[info exists tclDir]} {
##    set runLog "run"
##    set commandLog "command"
##    set criticalLog "critical"
## 
##    set logs [list $runLog $commandLog $criticalLog]
##    foreach log $logs {
##       if {[file exists ${log}.log]} {
##          file copy -force $log.log ${log}_prev.log
##       }
##    }
## 
##    set RFH [open "$runLog.log" w]
##    set CFH [open "$commandLog.log" w]
##    set WFH [open "$criticalLog.log" w]
## }
## proc log_time {phase start_time end_time {header 0} {notes ""}} {
##    global RFH
##    upvar #1 rfh rfh
## 
##    if {![info exists rfh]} {
##       set rfh "stdout"
##    }
## 
##    #Define widths of each column
##    set widthCol1 19
##    set widthCol2 13
##    set widthCol3 25
##    set widthCol4 65
## 
##    #Calculate times based of passed in times
##    set total_seconds [expr $end_time - $start_time]
##    set total_minutes [expr $total_seconds / 60]
##    set total_hours [expr $total_minutes / 60]
## 
##    if {$header} {
##       puts $rfh "\n| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##       puts $rfh [format "| %-*s | %-*s | %-*s | %-*s |" $widthCol1 "Phase" $widthCol2 "Time in Phase" $widthCol3 "Time\/Date" $widthCol4 "Description"]
##       puts $rfh "| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##       if {[info exists RFH]} {
##          puts $RFH "\n| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##          puts $RFH [format "| %-*s | %-*s | %-*s | %-*s |" $widthCol1 "Phase" $widthCol2 "Time in Phase" $widthCol3 "Time\/Date" $widthCol4 "Description"]
##          puts $RFH "| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##       }
##    }
## 
##    if {[string match $phase final]} {
##       set time "[format %02d [expr $total_hours]]h:[format %02d [expr $total_minutes-($total_hours*60)]]m:[format %02d [expr $total_seconds-($total_minutes*60)]]s"
##       puts $rfh "Total time:\t\t$time\n\n"
##       if {[info exists RFH]} {
##          puts $RFH "Total time:\t\t$time\n\n"
##       }
##    } else {
##       set time "[format %02d [expr $total_hours]]h:[format %02d [expr $total_minutes-($total_hours*60)]]m:[format %02d [expr $total_seconds-($total_minutes*60)]]s"
##       set date "[clock format $start_time -format {%H:%M:%S %a %b %d %Y}]"
##       puts $rfh [format "| %-*s | %-*s | %-*s | %-*s |" $widthCol1 "$phase" $widthCol2 "$time" $widthCol3 "$date" $widthCol4 "$notes"]
##       puts $rfh "| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##       if {[info exists RFH]} {
##          puts $RFH [format "| %-*s | %-*s | %-*s | %-*s |" $widthCol1 "$phase" $widthCol2 "$time" $widthCol3 "$date" $widthCol4 "$notes"]
##          puts $RFH "| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##       } 
##    } 
##    if {[info exists RFH]} {
##       flush $RFH
##    }
##    if {![string match $rfh "stdout"]} {
##       flush $rfh
##    }
## }
## proc command { command  {log ""} {quiet 0} } {
##    global verbose CFH
##    upvar #1 cfh cfh
##    
##    if {![info exists cfh]} {
##       set cfh "stdout"
##    }
## 
##    if {![info exists CFH]} {
##       set CFH "stdout"
##    }
## 
##    #Write all commands to command.log if file hanlde exists
##    if {![string match $cfh "stdout"]} {
##       if {[llength $log]} {
##          puts $cfh "$command \> $log"
##       } else {
##          puts $cfh $command
##       }
##       flush $cfh
##    }
##    if {![string match $CFH "stdout"]} {
##       if {[llength $log]} {
##          puts $CFH "$command \> $log"
##       } else {
##          puts $CFH $command
##       }
##       flush $CFH
##    }
## 
##    #ignore new-line, comments, or if verbose=0 (to generate scripts only)
##    if {[string match "\n" $command] || [string match "#*" $command] || !$verbose} {
##       return 0
##    }
## 
##    if {$verbose > 1} {
##       puts "\tCOMMAND: $command"
##    }
## 
##    set commandName [lindex [split $command] 0]
##    if {[llength $log] > 0} {
##       if { [catch "$command > $log" errMsg] && !$quiet } {
##          puts "#HD: Command \'$commandName\' failed! Parsing $log for relavant messages"
##          parse_log $log
##          regexp {(\.*.*)(\..*)} $log matched logName logType
##          #If design is open write out a debug DCP
##          if { ![catch {current_instance}] } {
##             puts "#HD: Writing checkpoint ${logName}_error.dcp for debug."
##             command "write_checkpoint -force ${logName}_error.dcp"
##          }
##          #upvar start_time start_time
##          upvar #1 start_time start_time
##          set end_time [clock seconds]
##          log_time $commandName $start_time $end_time 0 $errMsg
##          append errMsg "\nERROR: $commandName command \"$command\" failed.\nSee log file $log for more details."
##          error $errMsg
##       }
##       #Prevent messages from being dumped to terminal if quiet mode
##       if {!$quiet} {
##          parse_log $log
##       }
##    } else {
##       if { [catch $command errMsg] && !$quiet} {
##          append errMsg "\nERROR: $commandName command failed.\n\t$command\n"
##          error $errMsg
##       }
##    }
## }
## proc parse_log { log } {
##    global RFH WFH
##    upvar #1 wfh wfh
##    upvar #1 rfh rfh
## 
##    if {![info exists WFH]} {
##       set WFH "stdout"
##    }
##    if {![info exists rfh]} {
##       set rfh "stdout"
##    }
##    if {![info exists wfh]} {
##       set wfh "stdout"
##    }
##    if {[file exists $log]} {
##       set lfh [open $log r]
##       set log_data [read $lfh]
##       close $lfh
##       set log_lines [split $log_data "\n" ]
##       puts $wfh "\t#HD: Parsing log file \"$log\":"
##       puts $WFH "\t#HD: Parsing log file \"$log\":"
##       foreach line $log_lines {
##          if {[string match "CRITICAL WARNING*" $line]} {
##             puts $wfh "\t$line"
##             puts $WFH "\t$line"
##          }
##          if {[string match "ERROR:*" $line]} {
##             puts $rfh $line
##             puts $RFH $line
##             puts $line
##          }
##       }
##    } else {
##       puts $wfh "ERROR: Could not find specified log file \"$log\"."
##       puts $WFH "ERROR: Could not find specified log file \"$log\"."
##    }
##    puts $wfh "\n"
##    puts $WFH "\n"
##    flush $wfh
##    flush $WFH
## }
## proc getTimingInfo { {report {}} } {
##    global RFH
##    upvar #1 rfh rfh
## 
##    if {![info exists RFH]} {
##       set RFH "stdout"
##    }
## 
##    if {$report == {}} { 
##       set report [split [report_timing_summary -no_detailed_paths -no_check_timing -no_header -return_string] \n]
##    } else {
##       set report [split $report \n]
##    }
## 
##    foreach {wns tns tnsFailingEp tnsTotalEp whs ths thsFailingEp thsTotalEp wpws tpws tpwsFailingEp tpwsTotalEp} [list {N/A} {N/A} {N/A} {N/A} {N/A} {N/A} {N/A} {N/A} {N/A} {N/A} {N/A} {N/A}] { 
##       break 
##    }
##    if {[set i [lsearch -regexp $report {Design Timing Summary}]] != -1} {
##       foreach {wns tns tnsFailingEp tnsTotalEp whs ths thsFailingEp thsTotalEp wpws tpws tpwsFailingEp tpwsTotalEp} [regexp -inline -all -- {\S+} [lindex $report [expr $i + 6]]] { 
##          break 
##       }
##    }
##    puts "Setup:\n\t| WNS=$wns | TNS=$tns | Failing Endpoints=$tnsFailingEp | Total Endpoints=$tnsTotalEp |"
##    puts "Hold:\n\t| WHS=$whs | THS=$ths | Failing Endpoints=$thsFailingEp | Total Endpoints=$thsTotalEp |"
##    puts "Pulse Width:\n\t | WPWS=$wpws | TPWS=$tpws | Failing Endpoints=$tpwsFailingEp | Total Endpoints=$tpwsTotalEp |\n\n"
##    puts $RFH "Setup:\n\t| WNS=$wns | TNS=$tns | Failing Endpoints=$tnsFailingEp | Total Endpoints=$tnsTotalEp |"
##    puts $RFH "Hold:\n\t| WHS=$whs | THS=$ths | Failing Endpoints=$thsFailingEp | Total Endpoints=$thsTotalEp |"
##    puts $RFH "Pulse Width:\n\t | WPWS=$wpws | TPWS=$tpws | Failing Endpoints=$tpwsFailingEp | Total Endpoints=$tpwsTotalEp |\n\n"
##    puts $rfh "Setup:\n\t| WNS=$wns | TNS=$tns | Failing Endpoints=$tnsFailingEp | Total Endpoints=$tnsTotalEp |"
##    puts $rfh "Hold:\n\t| WHS=$whs | THS=$ths | Failing Endpoints=$thsFailingEp | Total Endpoints=$thsTotalEp |"
##    puts $rfh "Pulse Width:\n\t | WPWS=$wpws | TPWS=$tpws | Failing Endpoints=$tpwsFailingEp | Total Endpoints=$tpwsTotalEp |\n\n"
## }
## proc read_file_lines {file} {
##    if {![file exists $file]} {
##       puts "Error: Specified file $file does not exist. Please check path."
##       return
##    }
##    set fh [open $file r]
##    set fileData [read $fh]
##    close $fh
##    set fileLines [split $fileData "\n" ]
##    return $fileLines
## }
## proc print_table { args } {
##    set args [join $args]
##    set title "Table"
##    set FH "stdout"
## 
##    #Override defaults with command options
##    set argLength [llength $args]
##    set index 0
##    set rowCount 0
##    while {$index < $argLength} {
##       set arg [lindex $args $index]
##       set value [lindex $args [expr $index+1]]
##       switch -exact -- $arg {
##          {-title}    {set title $value}
##          {-row}      {dict set rows row${rowCount} $value
##                       incr rowCount
##                      }
##          {-file}     {set FH [open $value w]}
##          {-handle}   {upvar $value FH}
##          {-help}     {set     helpMsg "Description:"
##                       lappend helpMsg "Prints out a table in order the Rows are specified.\n"
##                       lappend helpMsg "Syntax:"
##                       lappend helpMsg "print_table\t\[-row <row1>] ... \[-row <rowN] \[-file <arg>]\n"
##                       lappend helpMsg "Usage:"
##                       lappend helpMsg "  Name                        Description"
##                       lappend helpMsg "  -------------------------------------------------------------------------------"
##                       lappend helpMsg "  \[-title]                    Optional. Defines the title of the table."
##                       lappend helpMsg "                              A default table name is used if no title is defined" 
##                       lappend helpMsg "  \[-row]                      Required. Defines a Row of the table to be printed."
##                       lappend helpMsg "                              The order the rows are defined is the print order." 
##                       lappend helpMsg "  \[-file]                     Optional. Specifies the output file name."
##                       lappend helpMsg "                              If not specified the output will be written to STDOUT"
##                       lappend helpMsg "  \[-help]                     Displays this message\n\n"
##                       foreach line $helpMsg {
##                          puts $FH $line
##                       }
##                       return
##                      }
##          default     {set errMsg "ERROR: Specified argument $arg is not supported.\n"
##                       append errMsg "Supported arguments are -help, -title, -row, and -file.\n"
##                       append errMsg "Use the -help option for more details"
##                       error $errMsg 
##                      }
##       }
##       set index [expr $index + 2]
##    }
## 
## 
##    #Create an array for column widths for each header entry
##    set headers [dict get $rows row0]
##    set colCount 0
##    set colTotal [llength $headers]
##    foreach header $headers {
##       set colWidth($colCount) [expr [string length $header] + 1]
##       incr colCount
##    }
## 
##    
##    #Get max length of entry, and update colWidth if necessary
##    dict for {row entries} $rows {
##       set colCount 0
##       set rowTotal [llength $entries]
##       if {$rowTotal != $colTotal} {
##          set errMsg "Error: The number of entries for $row does match the number of entries for row0.\n"
##          append errMsg "row0: [dict get $rows row0]\n"
##          append errMsg "$row: [dict get $rows $row]\n"
##          error $errMsg
##       }
##       foreach cell $entries {
##          set length [expr [string length $cell] + 1]
##          #puts "$colCount: $cell: $length"
##          if {$length > $colWidth($colCount) } {
##             set colWidth($colCount) $length
##          }
##          incr colCount
##       }
##    }
## 
##    #Create a string to seperate each row/column of data
##    set separator "|"
##    set colCount 0
##    foreach {key value} [array get colWidth] {
##       set width $colWidth($colCount)
##       append separator " [string repeat - $width] |"
##       incr colCount
##    }
## 
##    #Create the necessary string for each row to be used with "format" command
##    #[format "| %-*s | %-*s | %-*s | %-*s | %-*s | %-*s |" $width1 $value1 $width2 $value2 ... $widthN $valueN]
##    set rowCount 0
##    dict for {row entries} $rows {
##       dict set table row${rowCount} "\"|"
##       foreach cell $entries {
##          dict append table row${rowCount} " %-*s |"
##       }
##       dict append table row${rowCount} "\""
##       #puts "[dict get $table row${rowCount}]"
##       incr rowCount
##    }
## 
##    #Add additional information to each row to complete information needed for "format" command
##    #[format "| %-*s | %-*s | %-*s | %-*s | %-*s | %-*s |" $width1 $value1 $width2 $value2 ... $widthN $valueN]
##    set rowCount 0
##    dict for {row entries} $rows {
##       set col 0
##       foreach cell $entries {
##          dict append table row${rowCount} " $colWidth($col) \"$cell\""
##          incr col
##       }
##       #puts "[dict get $table row${rowCount}]"
##       incr rowCount
##    }
## 
##    #Print the Table
##    puts $FH "\n$title:"
##    dict for {row value} $table {
##       puts $FH $separator
##       puts $FH [eval format $value]
##    }
##    puts $FH "$separator\n"
## 
##    #Close the file handle if -file was specified
##    if {![string match $FH "stdout"]} {
##       close $FH
##    }
## }
# source $tclDir/synth_utils.tcl
## source $tclDir/synthesize.tcl
### proc synthesize { module } {
###    global tclParams 
###    global part 
###    global board 
###    global synthDir
###    global srcDir
###    global verbose
###    global RFH
###    
###    set moduleName  [get_attribute module $module moduleName]
###    set topLevel    [get_attribute module $module top_level]
###    set prj         [get_attribute module $module prj]
###    set includes    [get_attribute module $module includes]
###    set generics    [get_attribute module $module generics]
###    set vlogHeaders [get_attribute module $module vlog_headers]
###    set vlogDefines [get_attribute module $module vlog_defines]
###    set sysvlog     [get_attribute module $module sysvlog]
###    set vlog        [get_attribute module $module vlog]
###    set vhdl        [get_attribute module $module vhdl]
###    set ip          [get_attribute module $module ip]
###    set ipRepo      [get_attribute module $module ipRepo]
###    set bd          [get_attribute module $module bd]
###    set cores       [get_attribute module $module cores]
###    set xdc         [get_attribute module $module xdc]
###    set synthXDC    [get_attribute module $module synthXDC]
###    set options     [get_attribute module $module synth_options]
### 
###    set resultDir "$synthDir/$module"
### 
###    # Make the synthesis directory if needed
###    if {![file exists $synthDir]} {
###       file mkdir $synthDir
###    }
###    # Clean-out and re-make the synthesis directory for this module
###    file delete -force $resultDir
###    file mkdir $resultDir
###    
###    #Open local log files
###    set rfh [open "$resultDir/run.log" w]
###    set cfh [open "$resultDir/command.log" w]
###    set wfh [open "$resultDir/critical.log" w]
###    
###    set vivadoVer [version]
###    puts $rfh "Info: Running Vivado version $vivadoVer"
###    puts $RFH "Info: Running Vivado version $vivadoVer"
### 
###    command "puts \"#HD: Running synthesis for block $module\""
###    puts "\tWriting results to: $resultDir"
###    set synth_start [clock seconds]
### 
###    #### Set Tcl Params
###    if {[info exists tclParams] && [llength $tclParams] > 0} {
###       set_parameters $tclParams
###    }
### 
###    #Create in-memory project
###    command "create_project -in_memory -part $part" "$resultDir/create_project.log"
### 
###    if {[info exists board] && [llength $board]} {
###       command "set_property board_part $board \[current_project\]"
###    }
### 
###    #### Setup any IP Repositories 
###    if {$ipRepo != ""} {
###       puts "\tLoading IP Repositories:\n\t+ [join $ipRepo "\n\t+ "]"
###       command "set_property IP_REPO_PATHS \{$ipRepo\} \[current_fileset\]" "$resultDir/temp.log"
###       command "update_ip_catalog" "$resultDir/temp.log"
###    }
###    
###    set start_time [clock seconds]
###    if {[llength $prj] > 0} {
###       add_prj $prj
###       set end_time [clock seconds]
###       log_time add_prj $start_time $end_time 1 "Process PRJ file"
###    } else {
###       #### Read in System Verilog
###       if {[llength $sysvlog] > 0} {
###          add_sysvlog $sysvlog
###       }
###    
###       #### Read in Verilog
###       if {[llength $vlog] > 0} {
###          add_vlog $vlog
###       }
###    
###       #### Read in VHDL
###       if {[llength $vhdl] > 0} {
###          add_vhdl $vhdl
###       }
###       set end_time [clock seconds]
###       log_time add_files $start_time $end_time 1 "Add source files"
###    }
###       
###    #### Read IP from Catalog
###    if {[llength $ip] > 0} {
###       set start_time [clock seconds]
###       add_ip $ip
###       set end_time [clock seconds]
###       log_time add_ip $start_time $end_time 0 "Add XCI files and generate/synthesize IP"
###    }
###       
###    #### Read IPI systems
###    if {[llength $bd] > 0} {
###       set start_time [clock seconds]
###       add_bd $bd
###       set end_time [clock seconds]
###       log_time add_bd $start_time $end_time 0 "Add/generate IPI block design"
###    }
###    
###    #### Read in IP Netlists 
###    if {[llength $cores] > 0} {
###       set start_time [clock seconds]
###       add_cores $cores
###       set end_time [clock seconds]
###       log_time add_cores $start_time $end_time 0 "Add synthesized IP (DCP, NGC, EDIF)"
###    }
###    
###    #### Read in synthXDC files
###    if {[llength $synthXDC] > 0} {
###       set start_time [clock seconds]
###       add_xdc $synthXDC 2
###       set end_time [clock seconds]
###       log_time add_xdc $start_time $end_time 0 "Add synthesis only XDC files"
###    }
### 
###    #### Read in XDC file
###    if {[llength $xdc] > 0} {
###       set start_time [clock seconds]
###       add_xdc $xdc 1 
###       set end_time [clock seconds]
###       log_time add_xdc $start_time $end_time 0 "Add XDC files"
###    }
### 
###    if {[llength $xdc] == 0 && [llength $synthXDC] == 0} {
###       puts "\tInfo: No XDC file specified for $module"
###    }
### 
###    #### Set Verilog Headers 
###    if {[llength $vlogHeaders] > 0} {
###       foreach file $vlogHeaders {
###          command "set_property file_type {Verilog Header} \[get_files $file\]"
###       }
###    }
###    
###    #### Set Verilog Defines
###    if {$vlogDefines != ""} {
###       command "set_property verilog_define \{$vlogDefines\} \[current_fileset\]"
###    }
###    
###    #### Set Include Directories
###    if {$includes != ""} {
###       command "set_property include_dirs \{$includes\} \[current_fileset\]"
###    }
###    
###    #### Set Generics
###    if {$generics != ""} {
###       command "set_property generic $generics \[current_fileset\]"
###    }
###    
###    #### synthesis
###    puts "\tRunning synth_design"
###    set start_time [clock seconds]
###    if {$topLevel} {
###       command "synth_design -mode default $options -top $moduleName -part $part" "$resultDir/${moduleName}_synth_design.rds"
###    } else {
###       command "synth_design -mode out_of_context $options -top $moduleName -part $part" "$resultDir/${moduleName}_synth_design.rds"
###    }
###    set end_time [clock seconds]
###    log_time synth_design $start_time $end_time 0 "$moduleName $options"
###    
###    set start_time [clock seconds]
###    command "write_checkpoint -force $resultDir/${moduleName}_synth.dcp" "$resultDir/write_checkpoint.log"
###    set end_time [clock seconds]
###    log_time write_checkpiont $start_time $end_time 0 "Write out synthesis DCP"
###    
###    if {$verbose >= 1} {
###       set start_time [clock seconds]
###       command "report_utilization -file $resultDir/${moduleName}_utilization_synth.rpt" "$resultDir/temp.log"
###       set end_time [clock seconds]
###       log_time report_utilization $start_time $end_time 0 "Report Synthesis Utilization of $module"
###    }
###    set synth_end [clock seconds]
###    log_time final $synth_start $synth_end
###    command "close_project"
###    command "puts \"#HD: Synthesis of module $module complete\\n\""
###    close $rfh
###    close $cfh
###    close $wfh
### }
## proc add_prj { prj } {
##    global srcDir
## 
##    if {[file exists $prj]} {
##       puts "\tParsing PRJ file: $prj"
##       set source [open $prj r]
##       set source_data [read $source]
##       close $source
##       #Remove quotes from PRJ file
##       regsub -all {\"} $source_data {} source_data
##       set prj_lines [split $source_data "\n" ]
##       set line_count 0
##       foreach line $prj_lines {
##          incr line_count
##          #Ignore empty and commented lines
##          if {[llength $line] > 0 && ![string match -nocase "#*" $line]} {
##             if {[llength $line]!=3} {
##                set errMsg "\nERROR: Line $line_count is invalid format. Should be:\n\t<file_type> <library> <file>"
##                error $errMsg
##             }
##             lassign $line type lib file
##             if {![string match -nocase $type "dcp"]     && \
##                 ![string match -nocase $type "xci"]     && \
##                 ![string match -nocase $type "header"]  && \
##                 ![string match -nocase $type "system"]  && \
##                 ![string match -nocase $type "verilog"] && \
##                 ![string match -nocase $type "vhdl"]} {
##                set errMsg "\nERROR: File type $type is not a supported value.\n"
##                append errMsg "Supported types are:\n\tdcp\n\txci\n\theader\n\tsystem\n\tverilog\n\tvhdl\n\t"
##                error $errMsg
##             }
##             if {[file exists ${srcDir}/$file]} {
##                set file ${srcDir}/$file
##                command "add_files $file" "add_files.log"
##                if {[string match -nocase $type "vhdl"]} {
##                   command "set_property LIBRARY $lib \[get_files $file\]"
##                }
##                if {[string match -nocase $type "system"]} {
##                   command "set_property FILE_TYPE SystemVerilog \[get_files $file\]"
##                }
##                if {[string match -nocase $type "header"]} {
##                    command "set_property FILE_TYPE {Verilog Header} \[get_files $file\]"
##                }
##             } elseif {[file exists $file]} {
##                command "add_files $file"
##                if {[string match -nocase $type "vhdl"]} {
##                   command "set_property LIBRARY $lib \[get_files $file\]"
##                }
##                if {[string match -nocase $type "system"]} {
##                   command "set_property FILE_TYPE SystemVerilog \[get_files $file\]"
##                }
##                if {[string match -nocase $type "header"]} {
##                    command "set_property FILE_TYPE {Verilog Header} \[get_files $file\]"
##                }
##             } else {
##                puts "ERROR: Could not find file \"$file\" on line $line_count."
##                set error 1
##             }
##          }
##       }
##       if {[info exists error]} {
##          set errMsg "\nERROR: Files not found. Check messages for more details.\n"
##          error $errMsg
##       }
##    } else {
##       set errMsg "\nERROR: Could not find PRJ file $prj"
##       error $errMsg
##    }
## }
## proc add_bd { files } {
##    upvar resultDir resultDir
## 
##    foreach file $files {
##       if {[string length file] > 0} { 
##          if {[file exists $file]} {
##             set bd_split [split $file "/"] 
##             set bd [lindex $bd_split end]
##             set bdName [lindex [split $bd "."] 0]
##             if {[regexp {.*\.tcl} $file]} {
##                command "source $file"
##                command "generate_target all \[get_files .srcs/sources_1/bd/${bdName}/${bdName}.bd\]"
##             } else {
##                command "add_files $file" "$resultDir/add_bd.log"
##                command "generate_target all \[get_files $file]" "$resultDir/${bdName}_generate.log"
##             }
##          } else {
##             set errMsg "\nERROR: Could not find specified BD file: $file" 
##             error $errMsg
##          }
##       }
##    }
## }
## proc add_sysvlog { sysvlog } {
##    set files [join $sysvlog]
##    foreach file $files {
##       if {[file exists $file]} {
##          command "add_files $file"
##          command "set_property FILE_TYPE SystemVerilog \[get_files $file\]"
##       } else {
##          puts "ERROR: Could not find file \"$file\"."
##          set error 1;
##       }
##    }
##    if {[info exists error]} {
##       set errMsg "\nERROR: Files not found. Check messages for more details.\n"
##       error $errMsg
##    }
## }
## proc add_vlog { vlog } {
##    set files [join $vlog]
##    foreach file $files {
##       if {[file exists $file]} {
##          command "add_files $file"
##       } else {
##          puts "ERROR: Could not find file \"$file\"."
##          set error 1;
##       }
##    }
##    if {[info exists error]} {
##       set errMsg "\nERROR: Files not found. Check messages for more details.\n"
##       error $errMsg
##    }
## }
## proc add_vhdl { vhdl } {
##    set index 0
##    while {$index < [llength $vhdl]} {
##       set lib [lindex $vhdl [expr $index+1]]
##       foreach file [lindex $vhdl $index] {
##          if {[file exists $file]} {
##             command "add_files $file"
##             command "set_property LIBRARY $lib \[get_files $file\]"
##          } else {
##             puts "ERROR: Could not find file \"$file\"."
##             set error 1;
##          }
##       }
##       set index [expr $index+2]
##    }
##    if {[info exists error]} {
##       set errMsg "\nERROR: Files not found. Check messages for more details.\n"
##       error $errMsg
##    }
## }
# source $tclDir/impl_utils.tcl
## if {[info exists tclDir]} {
##    source $tclDir/implement.tcl
##    source $tclDir/step.tcl
## }
### proc implement {impl} {
###    global tclParams 
###    global board
###    global part
###    global dcpLevel
###    global verbose
###    global implDir
###    global xdcDir
###    global dcpDir
###    global RFH
### 
###    set top                 [get_attribute impl $impl top]
###    set name                [get_attribute impl $impl name]
###    set implXDC             [get_attribute impl $impl implXDC]
###    set cores               [get_attribute impl $impl cores]
###    set ip                  [get_attribute impl $impl ip]
###    set ipRepo              [get_attribute impl $impl ipRepo]
###    set hd                  [get_attribute impl $impl hd.impl]
###    set pr                  [get_attribute impl $impl pr.impl]
###    set hd.budget           [get_attribute impl $impl hd.budget]
###    set budgetExclude       [get_attribute impl $impl hd.budget_exclude]
###    set partitions          [get_attribute impl $impl partitions]
###    set link                [get_attribute impl $impl link]
###    set opt                 [get_attribute impl $impl opt]
###    set opt.pre             [get_attribute impl $impl opt.pre]
###    set opt_options         [get_attribute impl $impl opt_options]
###    set opt_directive       [get_attribute impl $impl opt_directive]
###    set place               [get_attribute impl $impl place]
###    set place.pre           [get_attribute impl $impl place.pre]
###    set place_options       [get_attribute impl $impl place_options]
###    set place_directive     [get_attribute impl $impl place_directive]
###    set phys                [get_attribute impl $impl phys]
###    set phys.pre            [get_attribute impl $impl phys.pre]
###    set phys_options        [get_attribute impl $impl phys_options]
###    set phys_directive      [get_attribute impl $impl phys_directive]
###    set route               [get_attribute impl $impl route]
###    set route.pre           [get_attribute impl $impl route.pre]
###    set route_options       [get_attribute impl $impl route_options]
###    set route_directive     [get_attribute impl $impl route_directive]
###    set post_phys           [get_attribute impl $impl post_phys]
###    set post_phys.pre       [get_attribute impl $impl post_phys.pre]
###    set post_phys_options   [get_attribute impl $impl post_phys_options]
###    set post_phys_directive [get_attribute impl $impl post_phys_directive]
###    set bitstream           [get_attribute impl $impl bitstream]
###    set bitstream.pre       [get_attribute impl $impl bitstream.pre]
###    set bitstream_options   [get_attribute impl $impl bitstream_options]
###    set bitstream_settings  [get_attribute impl $impl bitstream_settings]
###    set drc.quiet           [get_attribute impl $impl drc.quiet]
### 
###    if {($hd && $pr)} {
###       set errMsg "\nERROR: Implementation $impl has more than one of the following flow variables set to 1"
###       append errMsg "\n\thd.impl($hd)\n\tpr.impl($pr)\n"
###       append errMsg "Only one of these variables can be set true at one time. To run multiple flows, create separate implementation runs."
###       error $errMsg
###    }
### 
###    set resultDir "$implDir/$impl"
###    set reportDir "$resultDir/reports"
### 
###    #### Make the implementation directory, Clean-out and re-make the results directory
###    command "file mkdir $implDir"
###    command "file delete -force $resultDir"
###    command "file mkdir $resultDir"
###    command "file mkdir $reportDir"
###    
###    #### Open local log files
###    set rfh [open "$resultDir/run.log" w]
###    set cfh [open "$resultDir/command.log" w]
###    set wfh [open "$resultDir/critical.log" w]
### 
###    set vivadoVer [version]
###    puts $rfh "Info: Running Vivado version $vivadoVer"
###    puts $RFH "Info: Running Vivado version $vivadoVer"
### 
###    command "puts \"#HD: Running implementation $impl\""
###    puts "\tWriting results to: $resultDir"
###    puts "\tWriting reports to: $reportDir"
###    puts $rfh "\n#HD: Running implementation $impl"
###    puts $rfh "Writing results to: $resultDir"
###    puts $rfh "Writing reports to: $reportDir"
###    puts $RFH "\n#HD: Running implementation $impl"
###    puts $RFH "Writing results to: $resultDir"
###    puts $RFH "Writing reports to: $reportDir"
###    set impl_start [clock seconds]
### 
###    #### Set Tcl Params
###    if {[info exists tclParams] && [llength $tclParams] > 0} {
###       set_parameters $tclParams
###    }
### 
###    #### Create in-memory project
###    command "create_project -in_memory -part $part" "$resultDir/create_project.log"
###    if {[info exists board] && [llength $board]} {
###       command "set_property board_part $board \[current_project\]"
###    }   
### 
###    #### Setup any IP Repositories 
###    if {$ipRepo != ""} {
###       puts "\tLoading IP Repositories:\n\t+ [join $ipRepo "\n\t+ "]"
###       command "set_property IP_REPO_PATHS \{$ipRepo\} \[current_fileset\]" "$resultDir/temp.log"
###       command "update_ip_catalog" "$resultDir/temp.log"
###    }
### 
###    ###########################################
###    # Linking
###    ###########################################
###    if {$link} {
###       #Determine state of Top (import or implement). 
###       set topState "implement"
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          if {[string match $cell $top]} {
###             set topState $state 
###             if {[llength $dcp]} {
###                set topFile $dcp
###             }
###          }
###       }
### 
###       #If DCP for top is not defined in Partition settings, try and find it.
###       if {![info exist topFile] || ![llength $topFile]} {
###          foreach module [get_modules] {
###             set moduleName [get_attribute module $module moduleName]
###             if {[string match $top $moduleName]} {
###                break
###             }
###          }
###          if {[string match $topState "implement"]} {
###             set topFile [get_module_file $module]
###          } elseif {[string match $topState "import"]} {
###             if {$pr} {
###                set topFile "$dcpDir/${top}_static.dcp"
###             } else {
###                set topFile "$dcpDir/${top}_routed.dcp"
###             }
###          } else {
###             set errMsg "\nERROR: State of Top module $top is set to illegal state $topState." 
###             error $errMsg
###          }
###       }
### 
###       #Add file if it exists, or if $verbose=0 for testing
###       if {[file exists $topFile] || !$verbose} {
###          puts "\t#HD: Adding file $topFile for $top"
###          command "add_files $topFile"
###       } else {
###          set errMsg "\nERROR: Specified file $topFile cannot be found on disk. Verify path is correct, and that all dependencies have been run." 
###          error $errMsg
###       }
###    
###       ####Read in top-level cores, ip, and XDC if Top is being implemented
###       if {[string match $topState "implement"]} { 
###          # Read in IP Netlists 
###          if {[llength $cores] > 0} {
###             add_cores $cores
###          }
###          # Read IP XCI files
###          if {[llength $ip] > 0} {
###             add_ip $ip
###          }
### 
###          # Read in XDC files
###          if {[llength $implXDC] > 0} {
###             if {[string match $topState "implement"]} {
###                add_xdc $implXDC
###             } else {
###                puts "\tInfo: Skipping top-level XDC files because $top is set to $topState."
###             }
###          } else {
###             puts "\tWarning: No top-level XDC files were specified."
###          }
###       }
### 
###       ####Read in Partition netlist, cores, ip, and XDC if module is being implemented
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          if {![llength $name]} {
###             set name [lindex [split $cell "/"] end]
###          }
### 
###          if {![string match "greybox" $state]} {
###             set moduleName [get_attribute module $module moduleName]
###          } else {
###             set moduleName $module
###          }
### 
###          #Process each partition that is not Top. Ignore greybox Partitions
###          if {![string match $moduleName $top] && ![string match "greybox" $state]} {
###             #Find correct file to be used for Partition
###             if {[llength $dcp] && ![string match $state "greybox"]} {
###                set partitionFile $dcp
###             } else {
###                #if partition has state=implement, load synth netlist
###                if {[string match $state "implement"]} {
###                   set partitionFile [get_module_file $module]
###                } elseif {[string match $state "import"]} {
###                   #TODO: Name used to be based on Pblock to uniquify. Now no open design with new link_design flow,
###                   #      so no way to query Pblock name. This code will not work if RPs have same name at the end of hierarchy.
###                   #      Project flow names these cell DCPs based of full hierachy name, which can have issues of its own
###                   #      if the hierarchy name is very long.  Need to revisit to develop a solution.
###                   set partitionFile "$dcpDir/${name}_${module}_route_design.dcp"
###                } else {
###                   set errMsg "\nERROR: Invalid state \"$state\" in settings for $name\($impl)."
###                   append errMsg"Valid states are \"implement\", \"import\", or \"greybox\".\n" 
###                   error $errMsg
###                }
### 
###             }
###             #Add the partition source file to the in-memory project
###             if {![file exists $partitionFile]} {
###                set errMsg "ERROR: Partition \'$cell\' with state \'$state\' is set to use the file:\n$partitionFile\n\nThis file does not exist."
###                error $errMsg
###             }
###             set fileSplit [split $partitionFile "."]
###             set fileType [lindex $fileSplit end]
###             set start_time [clock seconds]
###             puts "\tAdding file $partitionFile for $cell ($module) \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###             command "add_file $partitionFile"
###             #Check if file is an XCI. SCOPED_TO_CELLS not supported for XCI
###             if {![string match [lindex [split $partitionFile .] end] "xci"]} {
###                #Check if this file is already scoped to another partition
###                if {[llength [get_property SCOPED_TO_CELLS [get_files $partitionFile]]]} {
###                   set cells [get_property SCOPED_TO_CELLS [get_files $partitionFile]]
###                   lappend cells $cell
###                   command "set_property SCOPED_TO_CELLS \{$cells\} \[get_files $partitionFile\]"
###                } else {
###                   command "set_property SCOPED_TO_CELLS $cell \[get_files $partitionFile\]"
###                }
###             }
### 
###             #Add Module specific implementation sources   
###             if {[string match $state "implement"]} { 
###                #Read in Module IP if module is not imported or greybox
###                set moduleIP [get_attribute module $module ip]
###                if {[llength $moduleIP] > 0} {
###                   puts "\tAdding module ip files for $cell ($module)"
###                   add_ip $moduleIP
###                }
### 
###                #Read in Module cores if module is not imported or greybox
###                set moduleCores [get_attribute module $module cores]
###                if {[llength $moduleCores] > 0} {
###                   puts "\tAdding module core files for $cell ($module)"
###                   add_cores $moduleCores
###                }
### 
###                #Read in scoped module impl XDC if module is not imported or greybox
###                #TODO: Integrate scoped XDC into add_xdc Tcl proc
###                set implXDC [get_attribute module $module implXDC]
###                if {[llength $implXDC] > 0} {
###                   puts "\tAdding scoped XDC files for $cell"
###                   foreach xdc $implXDC {
###                      if {[file exists $xdc]} {
###                         puts "\t#HD: Adding scoped 'xdc' file $xdc"
###                         command "add_files $xdc"
###                         command "set_property SCOPED_TO_CELLS $cell \[get_files $xdc\]"
###                      } else {
###                         set errMsg "\nERROR: Could not find specified XDC: $xdc" 
###                         error $errMsg 
###                      }
###                   }
###                } else {
###                   puts "\tInfo: No scoped XDC files specified for $cell"
###                }
###             }
###          }; #End: Process each partition that is not Top and not greybox
###       }; #End: Foreach partition
###    
###       ###########################################################
###       # Link the top-level design with no black boxes (unless greybox) 
###       ###########################################################
###       set start_time [clock seconds]
###       puts "\t#HD: Running link_design for $top \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###       set partitionCells ""
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          if {![string match $cell $top]} {
###             lappend partitionCells $cell
###          }
###       }
###       if {$pr} {
###          command "link_design -mode default -reconfig_partitions \{$partitionCells\} -part $part -top $top" "$resultDir/${top}_link_design.log"
###       } elseif {$hd} {
###          command "link_design -mode default -partitions \{$partitionCells\} -part $part -top $top" "$resultDir/${top}_link_design.log"
###       } else {
###          command "link_design -mode default -part $part -top $top" "$resultDir/${top}_link_design.log"
###       }
###       set end_time [clock seconds]
###       log_time link_design $start_time $end_time 1 "link_design -part $part -top $top"
###       
###       ##############################################
###       # Process Grey Box Partitions 
###       ##############################################
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          if {![llength $name]} {
###             set name [lindex [split $cell "/"] end]
###          }
### 
###          if {![string match "greybox" $state]} {
###             set moduleName [get_attribute module $module moduleName]
###          } else {
###             set moduleName $module
###          }
###          if {![string match $moduleName $top]} {
###             if {[string match "greybox" $state]} {
###                #If any greybox partition exist, need to run post-route DRC check in quiet mode
###                set drc.quiet 1
### 
###                #Process greybox partitions. Name can be random, so just grab name from partition def.
###                puts "\tInfo: Cell $cell will be implemented as a grey box."
###                set partitionFile "NA"
###    
###                #Insert LUT1 for greybox partition
###                if {$verbose && ![get_property IS_BLACKBOX [get_cells $cell]]} {
###                   set start_time [clock seconds]
###                   puts "\tCritical Warning: Partition cell \'$cell\' is not a blackbox. This likely occurred because OOC synthesis was not used. This can cause illegal optimization. Please verify it is intentional that this cell is not a blackbox at this stage in the flow.\nResolution: Caving out cell to make required blackbox. \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                   command "update_design -cells $cell -black_box" "$resultDir/update_design_blackbox_$name.log"
###                   set end_time [clock seconds]
###                   log_time update_design $start_time $end_time 0 "Create blackbox for $name"
###                }
###                command "set_msg_config -quiet -id \"Constraints 18-514\" -suppress"
###                command "set_msg_config -quiet -id \"Constraints 18-515\" -suppress"
###                command "set_msg_config -quiet -id \"Constraints 18-402\" -suppress"
###                set start_time [clock seconds]
###                puts "\t#HD: Inserting LUT1 buffers on interface of $name \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                command "update_design -cells $cell -buffer_ports" "$resultDir/update_design_bufferport_$name.log"
###                set end_time [clock seconds]
###                log_time update_design $start_time $end_time 0 "Convert blackbox partition $name to greybox"
###                set budgetXDC $xdcDir/${module}_budget.xdc
###                if {![file exists $budgetXDC] || ${hd.budget}} {
###                   set start_time [clock seconds]
###                   puts "\t#HD: Creating budget constraints for greybox $name \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                   create_partition_budget -cell $cell -file $budgetXDC -exclude $budgetExclude
###                   set end_time [clock seconds]
###                   log_time create_budget $start_time $end_time 0 "Create budget constraints for $name"
###                }
###                set start_time [clock seconds]
### #FIXED!! DELETE after VERIFICATION - Add DT on port nets to fix issues seen on RP where port connections got optimized in greybox flow.
### #               if {$verbose && [llength [get_nets -quiet -of [get_ports -quiet -of [get_nets -of [get_pins $cell/*]]]]]} { 
### #                  command "set_property DONT_TOUCH 1 \[get_nets -segments -of \[get_ports -of \[get_nets -of \[get_pins $cell/*\]\]\]\]"
### #               }
###                readXDC $budgetXDC
###                set end_time [clock seconds]
###                log_time read_xdc $start_time $end_time 0 "Read in budget constraints for $name"
###             }; #End: Process greybox partitions
###          }; #End: Process each partition that is not Top
###       }; #End: Foreach partition
###    
###       ##############################################
###       # Lock imported Partitions 
###       ##############################################
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          if {![string match "greybox" $state]} {
###             set moduleName [get_attribute module $module moduleName]
###          } else {
###             set moduleName $module
###          }
###          if {![string match $moduleName $top] && [string match $state "import"]} {
###             if {![llength $level]} {
###                set level "routing"
###             }
###             set start_time [clock seconds]
###             puts "\tLocking $cell \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###             command "lock_design -level $level $cell" "$resultDir/lock_design_$name.log"
###             set end_time [clock seconds]
###             log_time lock_design $start_time $end_time 0 "Locking cell $cell at level routing"
###          }; #End: Process each partition that is not Top
###       }; #End: Foreach partition
###       puts "\t#HD: Completed link_design"
###       puts "\t##########################"
### 
###       ##############################################
###       # Write out final link_design DCP 
###       ##############################################
###       if {$dcpLevel > 0} {
###          set start_time [clock seconds]
###          puts "\tWriting post-link_design checkpoint: $resultDir/${top}_link_design.dcp \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]\n"
###          command "write_checkpoint -force $resultDir/${top}_link_design.dcp" "$resultDir/write_checkpoint.log"
###          set end_time [clock seconds]
###          log_time write_checkpoint $start_time $end_time 0 "Post link_design checkpoint"
###       }
### 
###       if {$verbose > 1} {
###          set start_time [clock seconds]
###          puts "\tRunning report_utilization \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###          command "report_utilization -file $reportDir/${top}_utilization_link_design.rpt" "$resultDir/temp.log"
###          set end_time [clock seconds]
###          log_time report_utilization $start_time $end_time
###       } 
### 
###       ##############################################
###       # Run Methodology DRCs checks 
###       ##############################################
###       #Run methodology DRCs and catch any Critical Warnings or Error (module ruledeck quiet)
###       if {$verbose > 1} {
###          set start_time [clock seconds]
###          check_drc $top methodology_checks 1
###          set end_time [clock seconds]
###          log_time report_drc $start_time $end_time 0 "methodology checks"
###          #Run timing DRCs and catch any Critical Warnings or Error (module ruledeck quiet)
###          set start_time [clock seconds]
###          check_drc $top timing_checks 1
###          set end_time [clock seconds]
###          log_time report_drc $start_time $end_time 0 "timing_checks"
###       }
###    }; #END: if $link
### 
###    ############################################################################################
###    # Implementation steps: opt_design, place_design, phys_opt_design, route_design
###    ############################################################################################
###    if {$opt} {
###       #TEMPORARY: EXCLUDE_PLACEMENT is required, but HD.PARTITION is not implicity setting it as of now.
###       #Remove once this is implicity set, or no longer needed.
###       if {$hd && [string match $topState "implement"]} {
###          set hdPartitions [get_cells -hier -filter HD.PARTITION]
###          foreach partition $hdPartitions {
###             set pblock [get_pblocks -of $partition]
###             if {[llength $partition]} {
###                command "set_property EXCLUDE_PLACEMENT 1 \[get_pblocks $pblock\]"
###             } else {
###                set errMsg "\nERROR: No Pblock exists for Partition cell $partition"
###                error $errMsg
###             }
###          }
###       }
###       impl_step opt_design $top $opt_options $opt_directive ${opt.pre}
###    }
### 
###    if {$place} {
###       impl_step place_design $top $place_options $place_directive ${place.pre}
###    }
### 
###    if {$phys} {
###       impl_step phys_opt_design $top $phys_options $phys_directive ${phys.pre}
###    }
### 
###    if {$route} {
###       impl_step route_design $top $route_options $route_directive ${route.pre}
###  
###       if {$post_phys} {
###          impl_step post_phys_opt $top $post_phys_options $post_phys_directive ${post_phys.pre}
###       }
### 
###       #Run report_timing_summary on final design
###       set start_time [clock seconds]
###       puts "\tRunning report_timing_summary: $reportDir/${top}_timing_summary.rpt \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###       command "report_timing_summary -delay_type min_max -report_unconstrained -check_timing_verbose -max_paths 10 -input_pins -file $reportDir/${top}_timing_summary.rpt" "$resultDir/temp.log"
###       set end_time [clock seconds]
###       log_time report_timing $start_time $end_time 0 "Timing Summary"
### 
###       #Run a final DRC that catches any Critical Warnings (module ruledeck quiet)
###       set start_time [clock seconds]
###       check_drc $top bitstream_checks ${drc.quiet}
###       set end_time [clock seconds]
###       log_time report_drc $start_time $end_time 0 "bitstream_checks"
###    
###       #Report PR specific statitics for debug and analysis
###       if {$pr} {
###          set start_time
###          puts "\tRunning report_design_stauts: $reportDir/${top}_design_status.rpt \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###          command "debug::report_design_status" "$reportDir/${top}_design_status.rpt"
###       }
### 
###       if {$verbose} {
###          getTimingInfo
###       }
###       set impl_end [clock seconds]
###       log_time final $impl_start $impl_end 
###    }
###    
###    #For PR, don't write out bitstreams until after PR_VERIFY has run. See run.tcl
###    #For HD, run write_bitstream prior to creating blackbox or DRC errors will occur.
###    if {$bitstream && !$pr} {
###       impl_step write_bitstream $top $bitstream_options none ${bitstream.pre} $bitstream_settings
###    }
###    
###    set extras_start [clock seconds]
###    if {![file exists $dcpDir]} {
###       command "file mkdir $dcpDir"
###    }   
### 
###    if {$hd || $pr} {
###       #Write out cell checkpoints for all Partitions and create black_box 
###       puts $rfh "\n#HD: Running implementation $impl"
###       puts $RFH "\n#HD: Running implementation $impl"
###       #Generate a new header for a table the first time through
###       set header 1
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          #Don't try to get moduleName for greybox Partitions as the name can be random
###          if {![string match "greybox" $state]} { 
###             set moduleName [get_attribute module $module moduleName]
###          } else {
###             set moduleName $module
###          }
###   
###          if {![string match $moduleName $top]} {
###             #Only write out cell DCPs for implemented cells
###             if {([string match $state "implement"])} {
###                if {![llength $name]} {
###                   set name [lindex [split $cell "/"] end]
###                }
###                set start_time [clock seconds]
###                set dcp "$resultDir/${name}_${module}_route_design.dcp"
###                command "write_checkpoint -force -cell $cell $dcp" "$resultDir/write_checkpoint.log"
###                set end_time [clock seconds]
###                log_time write_checkpoint $start_time $end_time $header "Write cell checkpoint for $cell"
###                set header 0
###                command "file copy -force $dcp $dcpDir"
###             }
### 
###             #Carve out all partitions if Top/Static was implemented
###             if {[string match $topState "implement"]} {
###                set start_time [clock seconds]
###                puts "\tCarving out $cell to be a black box \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                command "update_design -cell $cell -black_box" "$resultDir/carve_$name.log"
###                set end_time [clock seconds]
###                log_time update_design $start_time $end_time $header "Carve out (blackbox) $cell"
###                set header 0
###             }
###          }
###       }
###    }
### 
###    #Write out implemented version of Top for import in subsequent runs
###    if {$pr || $hd} {
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          #Skip this step for greybox partitions to avoid errors in getting moduleName property
###          if {[string match "greybox" $state]} { 
###             continue
###          }
###          set moduleName [get_attribute module $module moduleName]
###          if {[string match $moduleName $top] && [string match $state "implement"]} {
###             set start_time [clock seconds]
###             puts "\t#HD: Locking $top and exporting results \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###             command "lock_design -level routing" "$resultDir/lock_design_$top.log"
###             set end_time [clock seconds]
###             log_time lock_design $start_time $end_time 0 "Lock placement and routing of $top"
###             if {$pr} {
###                set topDCP "$resultDir/${top}_static.dcp"
###             } 
###             if {$hd} {
###                set topDCP "$resultDir/${top}_routed.dcp"
###             }
###             set start_time [clock seconds]
###             command "write_checkpoint -force $topDCP" "$resultDir/write_checkpoint.log"
###             command "file copy -force $topDCP $dcpDir"
###             set end_time [clock seconds]
###             log_time write_checkpoint $start_time $end_time 0 "Write out locked Static checkpoint"
###          }
###       }
###    }
### 
###    set extras_end [clock seconds]
###    log_time final $extras_start $extras_end 
###    command "puts \"#HD: Implementation $impl complete\\n\""
###    command "close_project"
###    close $rfh
###    close $cfh
###    close $wfh
### }
### proc impl_step {phase instance {options none} {directive none} {pre none} {settings none} } {
###    global dcpLevel
###    global verbose
###    upvar  impl impl 
###    upvar  resultDir resultDir
###    upvar  reportDir reportDir
### 
###    #Make sure $phase is valid and set checkpoint in case no design is open
###    if {[string match $phase "opt_design"]} {
###       set checkpoint1 "$resultDir/${instance}_link_design.dcp"
###    } elseif {[string match $phase "place_design"]} {
###       set checkpoint1 "$resultDir/${instance}_opt_design.dcp"
###    } elseif {[string match $phase "phys_opt_design"]} {
###       set checkpoint1 "$resultDir/${instance}_place_design.dcp"
###    } elseif {[string match $phase "route_design"]} {
###       set checkpoint1 "$resultDir/${instance}_phys_opt_design.dcp"
###       set checkpoint2 "$resultDir/${instance}_place_design.dcp"
###    } elseif {[string match $phase "post_phys_opt"]} {
###       set checkpoint1 "$resultDir/${instance}_route_design.dcp"
###    } elseif {[string match $phase "write_bitstream"]} {
###       set checkpoint1 "$resultDir/${instance}_post_phys_opt.dcp"
###       set checkpoint2 "$resultDir/${instance}_route_design.dcp"
###    } else {
###       set errMsg "\nERROR: Value $phase is not a recognized step of implementation. Valid values are \"opt_design\", \"place_design\", \"phys_opt_design\", or \"route_design\"."
###       error $errMsg
###    }
###    #If no design is open
###    if { [catch {current_instance > $resultDir/temp.log} errMsg] && $verbose > 0 } {
###       puts "\tNo open design" 
###       if {[info exists checkpoint1] || [info exists checkpoint2]} {
###          if {[file exists $checkpoint1]} {
###             puts "\tOpening checkpoint $checkpoint1 for $instance"
###             command "open_checkpoint $checkpoint1" "$resultDir/open_checkpoint_${instance}_$phase.log"
###             if { [catch {current_instance > $resultDir/temp.log} errMsg] } {
###                command "link_design"
###             }
###          } elseif {[file exists $checkpoint2]} {
###             puts "\tOpening checkpoint $checkpoint2 for $instance"
###             command "open_checkpoint $checkpoint2" "$resultDir/open_checkpoint_${instance}_$phase.log"
###             if { [catch {current_instance > $resultDir/temp.log} errMsg] } {
###                command "link_design"
###             }
###          } else {
###             set errMsg "\nERROR: Checkpoint file not found. Please rerun necessary steps."
###             error $errMsg
###          }
###       } else {
###         set errMsg "\nERROR: No checkpoint defined."
###         error $errMsg
###       }
###    }
###   
###    #Run any specified pre-phase scripts
###    if {![string match $pre "none"] && ![string match $pre ""] } {
###       foreach script $pre {
###          if {[file exists $script]} {
###             puts "\t#HD: Running pre-$phase script $script"
###             command "source $script" "$resultDir/pre_${phase}_script.log"
###          } else {
###             set errMsg "\nERROR: Script $script specified for pre-${phase} does not exist"
###             error $errMsg
###          }
###       }
###    }
###  
###    #Append options or directives to command
###    if {[string match $phase "write_bitstream"]} {
###       set impl_step "$phase -force -file $resultDir/$instance"
###    } elseif {[string match $phase "post_phys_opt"]} {
###       set impl_step "phys_opt_design"
###    } else {
###       set impl_step $phase
###    }
### 
###    if {[string match $options "none"]==0 && [string match $options ""]==0} {
###       append impl_step " $options"
###    }
###    if {[string match $directive "none"]==0 && [string match $directive ""]==0} {
###       append impl_step " -directive $directive"
###    }
###    if {[string match $settings "none"]==0 && [string match $settings ""]==0} {
###       foreach setting $settings {
###          puts "\tSetting property $setting"
###          command "set_property $setting \[current_design]"
###       }
###    }
### 
###    #Run the specified Implementation phase
###    puts "\n\t#HD: Running $impl_step for $impl"
### 
###    set log "$resultDir/${instance}_$phase.log"
###    puts "\tWriting Results to $log"
### 
###    set start_time [clock seconds]
###    puts "\t$phase start time: \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###    command "$impl_step" "$log"
###    set end_time [clock seconds]
###    log_time $phase $start_time $end_time 0 "$impl_step" 
###    command "puts \"\t#HD: Completed: $phase\""
###    puts "\t################################"
###       
###    #Write out checkpoint for successfully completed phase
###    if {($dcpLevel > 0 || [string match $phase "route_design"]) && ![string match $phase "write_bitstream"]} {
###       set start_time [clock seconds]
###       puts "\tWriting post-$phase checkpoint: $resultDir/${instance}_$phase.dcp \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]\n"
###       command "write_checkpoint -force $resultDir/${instance}_$phase.dcp" "$resultDir/write_checkpoint.log"
###       set end_time [clock seconds]
###       log_time write_checkpoint $start_time $end_time 0 "Post-$phase checkpoint"
###    }
### 
###    #Write out additional reports controled by verbose level
###    if {$verbose > 1 || [string match $phase "route_design"]} {
###       set start_time [clock seconds]
###       command "report_utilization -file $reportDir/${instance}_utilization_${phase}.rpt" "$resultDir/temp.log"
###       set end_time [clock seconds]
###       log_time report_utilization $start_time $end_time
###    }
### 
###    if {[string match $phase "route_design"]} {
###       set start_time [clock seconds]
###       command "report_route_status -file $reportDir/${instance}_route_status.rpt" "$resultDir/temp.log"
###       set end_time [clock seconds]
###       log_time report_route_status $start_time $end_time
###    }
### }
## proc get_module_file { module } {
##    global synthDir
##    global ipDir
##    global netlistDir
##    
##    if {![info exists synthDir]} {
##       set synthDir "."
##    }
##    if {![info exists ipDir]} {
##       set ipDir "."
##    }
##    if {![info exists netlistDir]} {
##       set netlistDir "."
##    }
##    set moduleName [get_attribute module $module moduleName]
##    set synthDCP   [get_attribute module $module synthCheckpoint]
##    set searchFiles [list $synthDCP \
##                          $synthDir/$module/${moduleName}_synth.dcp  \
##                          $ipDir/$module/${moduleName}.xci           \
##                          $netlistDir/$module/${moduleName}.edf      \
##                          $netlistDir/$module/${moduleName}.edn      \
##                          $netlistDir/$module/${moduleName}.ngc      \
##                    ]
##    set moduleFile ""
##    foreach file $searchFiles {
##       if {[file exists $file]} {
##          set moduleFile $file
##          break
##       }
##    } 
##    if {![llength $moduleFile]} {
##       set errMsg "\nERROR: No synthesis netlist or checkpoint file found for $module."
##       append errMsg "\nSearched directories:"
##       foreach file $searchFiles {
##          append errMsg "\t$file\n"
##       }
##       error $errMsg
##    }
##    return $moduleFile
## }
## proc generate_pr_binfiles { config } {
##    upvar bitDir bitDir
## 
##    set top           [get_attribute impl $config top]
##    set partitions    [get_attribute impl $config partitions]
##    set icap          [get_attribute impl $config cfgmem.icap]
##    set pcap          [get_attribute impl $config cfgmem.pcap]
##    set offset        [get_attribute impl $config cfgmem.offset]
##    set size          [get_attribute impl $config cfgmem.size]
##    set interface     [get_attribute impl $config cfgmem.interface]
##    if {$icap || $pcap} {
##       foreach partition $partitions {
##          lassign $partition module cell state name type level dcp
##          if {![string match $cell $top]} {
##             set pblock [get_pblocks -quiet -of [get_cells $cell]]
##             if {[string match "greybox" $state]} {
##                set bitName "${pblock}_greybox_partial"
##             } else {
##                set bitName "${pblock}_${module}_partial"
##             }
##             set bitFile "$bitDir/${bitName}.bit"
##             if {![file exists $bitFile]} {
##                puts "\tCritical Warning: No bit file found for $cell ($module) in configuration $config. Skipping BIN file generation. Expected file \n\t$bitFile.\n\tRun write_bitstream first to generate the expected file."
##                return 
##             }
##             if {$icap} {
##                set logFile "$bitDir/write_cfgmem_${config}_${name}_icap.log"
##                set msg "\t#HD: Generating ICAP formatted BIN file for $name of Configuration $config"
##                command "puts \"$msg\""
##                set start_time [clock seconds]
##                set binFile "$bitDir/${config}_${pblock}_partial_icap.bin"
##                #command "write_cfgmem -force -format BIN -interface $interface -loadbit \"$offset $bitFile\" -size $size $binFile" $logFile
##                command "write_cfgmem -force -format BIN -interface $interface -loadbit \"$offset $bitFile\" $binFile" $logFile
##                set end_time [clock seconds]
##                log_time write_cfgmem $start_time $end_time 1 "Generate ICAP format bin file for ${config}(${name})"
##             }
##             if {$pcap} {
##                set logFile "$bitDir/write_cfgmem_${config}_${name}_pcap.log"
##                set msg "\t#HD: Generating PCAP formatted BIN file for $name of Configuration $config"
##                command "puts \"$msg\""
##                set start_time [clock seconds]
##                set binFile "$bitDir/${config}_${pblock}_partial_pcap.bin"
##                #command "write_cfgmem -force -format BIN -interface $interface -disablebitswap -loadbit \"$offset $bitFile\" -size $size $binFile" $logFile 
##                command "write_cfgmem -force -format BIN -interface $interface -disablebitswap -loadbit \"$offset $bitFile\" $binFile" $logFile 
##                set end_time [clock seconds]
##                log_time write_cfgmem $start_time $end_time 1 "Generate PCAP format bin file for ${config}(${name})"
##             }
##          }
##       }
##    } else {
##       puts "\tINFO: Skipping partial BIN file generation for Configuration $config."
##    }
## }
## proc generate_pr_bitstreams { configs } {
##    global dcpDir bitDir implDir
## 
##    #Set a default directory to write bitstreams if not already defined
##    if {![info exists bitDir]} {
##       set bitDir "./Bitstreams"
##    }
## 
##    #command "file delete -force $bitDir"
##    if {![file exists $bitDir]} {
##       command "file mkdir $bitDir"
##    }
## 
##    foreach config $configs {
##       set top               [get_attribute impl $config top]
##       set partitions        [get_attribute impl $config partitions]
##       set post_phys         [get_attribute impl $config post_phys]
##       set bitstream         [get_attribute impl $config bitstream]
##       set bitstream.pre     [get_attribute impl $config bitstream.pre]
##       set bitOptions        [get_attribute impl $config bitstream_options]
##       set bitSettings       [get_attribute impl $config bitstream_settings]
##       set partialOptions    [get_attribute impl $config partial_bitstream_options]
##       set partialSettings   [get_attribute impl $config partial_bitstream_settings]
##       if {$bitstream} {
##          set start_time [clock seconds]
##          set msg "\t#HD: Running write_bitstream on $config"
##          command "puts \"$msg\""
##          set logFile "$bitDir/write_bitstream_${config}.log"
##          if {$post_phys} {
##             set configFile "$implDir/$config/${top}_post_phys_opt.dcp"
##          } else {
##             set configFile "$implDir/$config/${top}_route_design.dcp"
##          }
##          if {[file exists $configFile]} {
##             command "open_checkpoint $configFile" "$bitDir/open_checkpoint_$config.log"
## 
##             #Run any pre.hook scripts for write_bitstream
##             foreach script ${bitstream.pre} {
##                if {[file exists $script]} {
##                   puts "\t#HD: Running pre-bitstream script $script"
##                   command "source $script" "$bitDir/pre_bitstream_script.log"
##                } else {
##                   set errMsg "\nERROR: Script $script specified for pre-bitstream does not exist"
##                   error $errMsg
##                }
##             }
## 
##             #Apply config settings for full bit file
##             foreach setting $bitSettings {
##                puts "\tSetting property $setting"
##                command "set_property $setting \[current_design\]"
##             }
##             #Generate full Bitstream
##             foreach partition $partitions {
##                lassign $partition module cell state name type level dcp
##                if {[string match $cell $top]} {
##                   #Generate full bitstream only
##                   command "write_bitstream -force $bitOptions $bitDir/${config}_full -no_partial_bitfile" "$bitDir/${config}_full.log"
##                }
##             }
## 
##             #Check for dbg_hub in Static and write out probes
##             if {[llength [get_cells -quiet -hier -filter REF_NAME==dbg_hub_CV]]} {
##                command "write_debug_probes -force $bitDir/${config}_full.ltx" "$bitDir/write_debug_probes_$config.log"
##             }
## 
##             #Apply any partial specfic config settings (ie. compression)
##             foreach setting $partialSettings {
##                puts "\tSetting property $setting"
##                command "set_property $setting \[current_design\]"
##             }
##             #Check for specific options for partial bit files. Otherwise default to full settings.
##             if {[llength $partialOptions]} {
##                set bitOptions $partialOptions
##             }
##             #Generate partials using -cell for better naming
##             foreach partition $partitions {
##                lassign $partition module cell state name type level dcp
##                if {![string match $cell $top]} {
##                   set pblock [get_pblocks -quiet -of [get_cells $cell]]
##                   if {[string match "greybox" $state]} {
##                      set bitName "${pblock}_greybox_partial"
##                   } else {
##                      set bitName "${pblock}_${module}_partial"
##                   }
##                   command "write_bitstream -force $bitOptions -cell $cell $bitDir/$bitName" "$bitDir/$bitName.log"
##                   #Check for dbg_bridge in RM and write out probes
##                   if {[llength [get_cells -quiet -hier -filter "REF_NAME==dbg_bridge && NAME=~$cell/*"]]} {
##                      command "write_debug_probes -force -cell $cell $bitDir/${bitName}.ltx" "$bitDir/write_debug_probes_$module.log"
##                   }
##                }
##             }
##          } else {
##             puts "\tInfo: Skipping write_bitstream for configuration $config because the file \'$configFile\' could not be found."
##             continue
##          }
## 
##          set end_time [clock seconds]
##          log_time write_bitstream $start_time $end_time 1 $config
##          generate_pr_binfiles $config 
##          command "close_project" "$bitDir/temp.log"
##       } else {
##          puts "\tSkipping write_bitstream for Configuration $config with attribute \"bitstream\" set to \'$bitstream\'"
##       }
##    }
## }
## proc verify_configs { configs } {
##    global implDir
## 
##    set configNames ""
##    set configFiles ""
##    foreach config $configs {
##       set verify [get_attribute impl $config verify]
##       set post_phys [get_attribute impl $config post_phys]
##       #Check if configuration has verify attribute set
##       if {$verify} {
##          set configTop [get_attribute impl $config top]
##          if {$post_phys} {
##             set configFile $implDir/$config/${configTop}_post_phys_opt.dcp
##          } else {
##             set configFile $implDir/$config/${configTop}_route_design.dcp
##          }
##          #Even with verify set, check if routed DCP exists before adding to the list to be verified
##          if {[file exists $configFile]} {
##             lappend configFiles $configFile
##             lappend configNames $config
##          } else {
##             puts "\tInfo: Skipping Configuration $config with attribute \"verify\" to \'$verify\' because file \'$configFile\' cannot be found."
##          }
##       } else {
##          puts "\tInfo: Skipping Configuration $config with attribute \"verify\" set to \'$verify\'"
##       }
##    }
##    
##    if {[llength $configFiles] > 1} {
##       set start_time [clock seconds]
##       set initialConfig [lindex $configNames 0]
##       set initialConfigFile [lindex $configFiles 0]
##       set additionalConfigs [lrange $configNames 1 end]
##       set additionalConfigFiles [lrange $configFiles 1 end]
##       set msg "#HD: Running pr_verify between initial Configuration \'$initialConfig\' and subsequent configurations \'$additionalConfigs\'"
##       command "puts \"$msg\""
##       set logFile "pr_verify_results.log"
##       command "pr_verify -full_check -initial $initialConfigFile -additional \{$additionalConfigFiles\}" $logFile
##       #Parse log file for errors or successful results
##       if {[file exists $logFile]} {
##          set lfh [open $logFile r]
##          set log_data [read $lfh]
##          close $lfh
##          set log_lines [split $log_data "\n" ]
##          foreach line $log_lines {
##             if {[string match "*Vivado 12-3253*" $line] || [string match "*ERROR:*" $line]} {
##                puts "$line"
##             }
##          }
##       }
##       set end_time [clock seconds]
##       log_time pr_verify $start_time $end_time 1 "[llength $configs] Configurations"
##    }
## }
## proc add_xdc { xdc { synth 0} } {
##    #Flatten list if nested lists exist
##    set files [join [join $xdc]]
##    foreach file $files {
##       if {[file exists $file]} {
##          puts "\t#HD: Adding 'xdc' file $file"
##          command "add_files $file"
##          set file_split [split $file "/"]
##          set fileName [lindex $file_split end]
##          if { $synth ==2 || [string match "*synth*" $fileName] } { 
##             if {[string match "*ooc*" $fileName]} {
##                command "set_property USED_IN {synthesis out_of_context} \[get_files $file\]"
##             } else {
##                command "set_property USED_IN {synthesis} \[get_files $file\]"
##             }
##          } elseif { $synth==1 } {
##             if {[string match "*ooc*" $fileName]} {
##                command "set_property USED_IN {synthesis implementation out_of_context} \[get_files $file\]"
##             } else {
##                command "set_property USED_IN {synthesis implementation} \[get_files $file\]"
##             }
##          } else {
##             if {[string match "*ooc*" $fileName]} {
##                command "set_property USED_IN {implementation out_of_context} \[get_files $file\]"
##             } else {
##                command "set_property USED_IN {implementation} \[get_files $file\]"
##             }
##          }
## 
##          if {[string match "*late*" $fileName]} {
##             command "set_property PROCESSING_ORDER late \[get_files $file\]"
##          } elseif {[string match "*early*" $fileName]} {
##             command "set_property PROCESSING_ORDER early \[get_files $file\]"
##          }
##       } else {
##          set errMsg "\nERROR: Could not find specified XDC: $file" 
##          error $errMsg 
##       }
##    }
## }
## proc readXDC { xdc {cell ""} } {
##    upvar resultDir resultDir
## 
##    puts "\tReading XDC files"
##    #Flatten list if nested lists exist
##    set files [join [join $xdc]]
##    foreach file $files {
##       if {[file exists $file]} {
##          if {![llength $cell]} {
##             command "read_xdc $file" "$resultDir/read_xdc.log"
##          } else {
##             command "read_xdc -cell $cell $file" "$resultDir/read_xdc_cell.log"
##          }
##       } else {
##          set errMsg "\nERROR: Could not find specified XDC: $file" 
##          error $errMsg 
##       }
##    }
## }
## proc add_ip { ips } {
##    upvar resultDir resultDir
## 
##    foreach ip $ips {
##       if {[string length ip] > 0} { 
##          if {[file exists $ip]} {
##             set ip_split [split $ip "/"] 
##             set xci [lindex $ip_split end]
##             set ipPathList [lrange $ip_split 0 end-1]
##             set ipPath [join $ipPathList "/"]
##             set ipName [lindex [split $xci "."] 0]
##             set ipType [lindex [split $xci "."] end]
##             puts "\t#HD: Adding \'$ipType\' file $xci"
##             command "add_files $ipPath/$xci" "$resultDir/${ipName}_add.log"
##             if {[string match $ipType "bd"]} {
##                return
##             }
##             if {[get_property GENERATE_SYNTH_CHECKPOINT [get_files $ipPath/$xci]]} {
##                if {![file exists $ipPath/${ipName}.dcp]} {
##                   puts "\tSynthesizing IP $ipName"
##                   command "synth_ip \[get_files $ipPath/$xci]" "$resultDir/${ipName}_synth.log"
##                }
##             } else {
##                puts "\tGenerating output for IP $ipName"
##                command "generate_target all \[get_ips $ipName]" "$resultDir/${ipName}_generate.log"
##             }
##          } else {
##             set errMsg "\nERROR: Could not find specified IP file: $ip" 
##             error $errMsg
##          }
##       }
##    }
## }
## proc add_cores { cores } {
##    #Flatten list if nested lists exist
##    set files [join [join $cores]]
##    foreach file $files {
##       if {[string length $file] > 0} { 
##          if {[file exists $file]} {
##             #Comment this out to prevent adding files 1 at a time. Add all at once instead.
##             puts "\t#HD: Adding core file $file"
##             command "add_files $file"
##          } else {
##             set errMsg "\nERROR: Could not find specified core file: $file" 
##             error $errMsg
##          }
##       }
##    }
## }
## proc check_drc { module {ruleDeck default} {quiet 0} } {
##    upvar reportDir reportDir
## 
##    if {[info exists reportDir]==0} {
##       set reportDir "."
##    }
##    puts "\t#HD: Running report_drc with ruledeck $ruleDeck.\n\tResults saved to $reportDir/${module}_drc_$ruleDeck.rpt" 
##    command "report_drc -ruledeck $ruleDeck -name $module -file $reportDir/${module}_drc_$ruleDeck.rpt" "$reportDir/temp.log"
##    set Advisories   [get_drc_violations -quiet -name $module -filter {SEVERITY=~"Advisory"}]
##    set Warnings     [get_drc_violations -quiet -name $module -filter {SEVERITY=~"Warning"}]
##    set CritWarnings [get_drc_violations -quiet -name $module -filter {SEVERITY=~"Critical Warning"}]
##    set Errors       [get_drc_violations -quiet -name $module -filter {SEVERITY=~"Error"}]
##    puts "\tAdvisories: [llength $Advisories]; Warnings: [llength $Warnings]; Critical Warnings: [llength $CritWarnings]; Errors: [llength $Errors];"
## 
##    if {[llength $Errors]} {
##       if {!$quiet} {
##          set errMsg "\nERROR: DRC found [llength $Errors] errors ($Errors)."
##       } else {
##          puts "\tCritical Warning: DRC found [llength $Errors] errors ($Errors)."
##       }
##       foreach error $Errors {
##          puts "\n\t${error}: [get_property DESCRIPTION [get_drc_violations -name $module $error]]"
##       }
##       #Stop the script for Errors, unless user specifies quiet as true
##       if {!$quiet} {
##          error $errMsg
##       }
##    }
## 
##    if {[llength $CritWarnings]} {
##       if {!$quiet} {
##          set errMsg "\nERROR: DRC found [llength $CritWarnings] Critical Warnings ($CritWarnings)."
##       } else {
##          puts "\tCritical Warning: DRC found [llength $CritWarnings] Critical Warnings ($CritWarnings)."
##       }
##       foreach cw $CritWarnings {
##          puts "\n\t${cw}: [get_property DESCRIPTION [get_drc_violations -name $module $cw]]"
##       }
##       #Stop the script for Critcal Warnings, unless user specifies quiet as true
##       if {!$quiet} {
##          error $errMsg
##       }
##    }
## }
## proc printRuleDecks { {decks ""} } {
##    if {[llength $decks]} {
##       set rules [get_drc_checks -of [get_drc_ruledecks $decks]]
##       foreach rule $rules {
##          set name [get_property NAME [get_drc_checks $rule]]
##          set description [get_property DESCRIPTION [get_drc_checks $rule]]
##          set severity [get_property SEVERITY [get_drc_checks $rule]]
##          puts "\t${name}(${severity}): ${description}"
##       }
##    } else {
##       puts "Rule Decks:\n\t[join [get_drc_ruledecks] "\n\t"]"
##    }
## }
## proc printRules { rules } {
##    foreach rule $rules {
##       set name [get_property NAME [get_drc_checks $rule]]
##       set description [get_property DESCRIPTION [get_drc_checks $rule]]
##       set severity [get_property SEVERITY [get_drc_checks $rule]]
##       puts "\t${name}(${severity}): $description"
##    }
## }
## proc fix_timing {} {
##    set clk_intr [split [report_clock_interaction -return_string] \n]
##    foreach line $clk_intr {
##       if { [regexp {^(\S+)\s+(\S+)\s+\S+.*Timed \(unsafe\).*} $line full src dst]} {
##          set_false_path -from [get_clocks $src] -to [get_clocks $dst]
##       }
##    }
## }
# source $tclDir/hd_utils.tcl
## proc get_partitions {} {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    set partitions [get_cells -quiet -hier -filter HD.PARTITION]
##    if {![llength $partitions]} {
##       puts "Info: No cells found with HD.PARTITION==1"
##       return
##    }
##    return $partitions
## }
## proc get_bb {} {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    set bb [get_cells -quiet -hier -filter IS_BLACKBOX]
##    if {![llength $bb]} {
##       puts "Info: No blackbox cells found"
##       return
##    }
##    return $bb
## }
## proc bb { cells } {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    foreach cell $cells {
##       update_design -black_box -cell $cell
##    }
## }
## proc gb { cells } {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    foreach cell $cells {
##       update_design -buffer_ports -cell $cell
##    }
## }
## proc create_partition_budget { args } {
##    set FH "stdout"
##    set excludePins ""
## 
##    #Override defaults with command options
##    set argLength [llength $args]
##    set index 0
##    while {$index < $argLength} {
##       set arg [lindex $args $index]
##       set value [lindex $args [expr $index+1]]
##       switch -exact -- $arg {
##          {-cell}     {set cell [get_cells $value]}
##          {-file}     {set FH [open $value w]}
##          {-exclude}  {set excludePins $value}
##          {-help}     {set     helpMsg "Description:"
##                       lappend helpMsg "Creates set_max_delay constraints for initial PR run.\n"
##                       lappend helpMsg "Syntax:"
##                       lappend helpMsg "create_partition_budget\ -cell <arg> \[-file <arg>] \[-exclude\]\n"
##                       lappend helpMsg "Usage:"
##                       lappend helpMsg "  Name                        Description"
##                       lappend helpMsg "  ---------------------------------------"
##                       lappend helpMsg "  \[-cell]                     Specifies the PR cell to process."
##                       lappend helpMsg "  \[-file]                     Optional. Specifies the output file name."
##                       lappend helpMsg "                              If not specified the output will be written to STDOUT"
##                       lappend helpMsg "  \[-exclude]                  Optional. List of pins to skip."
##                       lappend helpMsg "                              Specifies local pin names without hierachy"
##                       lappend helpMsg "  \[-help]                     Displays this message\n\n"
##                       foreach line $helpMsg {
##                          puts $line
##                       }
##                       return
##                      }
##          default     {set errMsg "ERROR: Specified argument $arg is not supported.\n"
##                       append errMsg "Supported arguments are -help, -cell, and -file.\n"
##                       append errMsg "Use the -help option for more details"
##                       error $errMsg 
##                      }
##       }
##       set index [expr $index + 2]
##    }
## 
##    set_msg_config -id "Constraints 18-514" -suppress
##    set_msg_config -id "Constraints 18-515" -suppress
##    set_msg_config -id "Constraints 18-402" -suppress
##    puts $FH "####Budget constraints for cell $cell####"
## 
## 
##    set filter "REF_NAME=~FD* || REF_NAME=~RAMB* || REF_NAME=~DSP* || REF_NAME=~SRL*"
##    set startPoints {}
##    set endPoints {}
## 
##    #Process Input Pins. Ignore pins tied to clock logic, IO buffer, or VCC/GND 
##    set inputs [get_pins -of [get_cells $cell] -filter DIRECTION==IN]
##    puts "\tProcessing Input Pins of cell $cell ([llength $inputs] pins)"
##    puts $FH "#Input pins:"
##    set count 0
##    foreach pin [lsort -dict $inputs] {
##       if {[lsearch -exact $excludePins [lindex [split $pin /] end]] > "-1"} {
##          puts "\tInfo: Skipping excluded pin $pin"
##          continue
##       }
##       set HD_LUT [get_cells -quiet -of [get_pins -quiet -leaf -filter NAME=~$cell/HD_PR* -of [get_nets -quiet -of [get_pins $pin]]]]
##       if {[llength $HD_LUT]} {
##          #Get the cell names and filter out GTs, BUFG, IBUF, etc.
##          set startPointCells [get_cells -quiet -filter $filter [all_fanin -quiet -startpoints_only -flat -only_cells $pin]]
##          set clockPins [get_pins -quiet -filter IS_CLOCK -of $startPointCells]
##          set clocks [get_clocks -quiet -of $clockPins]
##          if {[llength $clocks]} {
##             foreach clock $clocks {
##                set timingPaths [get_timing_paths -quiet -from $startPointCells -through $pin -nworst 100000 -filter STARTPOINT_CLOCK==$clock]
##                if {![llength $timingPaths]} {
##                   puts "\tInfo: No timing path found through pin $pin for clock $clock." 
##                   continue
##                }
## 
##                #set startPointPins [lsort -dict -unique [join [get_pins [get_property STARTPOINT_PIN $timingPaths] -filter $filter]]]
##                set startPointPins [lsort -dict -unique [get_pins [get_property STARTPOINT_PIN $timingPaths] -filter $filter]]
##                lappend startPoints [get_cells -of [get_pins $startPointPins]]
##                set logicLevels [lindex [lsort -dict [get_property LOGIC_LEVELS $timingPaths]] end]
##                set period [get_property PERIOD [get_clocks $clock]]
##                #If driver is RAMB*, add level of logic to account for large clk2out times
##                if {[lsearch [get_property REF_NAME [get_pins $startPointPins]] "RAMB*"] > "-1"} {
##                   set logicLevels [expr $logicLevels + 2]
##                }
##                if {$logicLevels < 1} {
##                   set percentage "0.4"
##                } elseif {$logicLevels < 2} {
##                   set percentage "0.5"
##                } elseif {$logicLevels < 3} {
##                   set percentage "0.6"
##                } elseif {$logicLevels < 4} {
##                   set percentage "0.7"
##                } elseif {$logicLevels >= 4} {
##                   set percentage "0.8"
##                   #puts "\tCritical Warning: Path found with $logicLevels levels of logic through pin $pin. Consider revising interface."
##                   #puts "\tPath has load clock $clock with period of ${period}ns. Interface budget set to ${percentage} of period."
##                }
## 
##                set value [expr $period * $percentage]
##                puts $FH "#Pin: $pin\tLogic Levels: $logicLevels\tClock: $clock\tPeriod: $period\tBudget: $percentage"
##                puts $FH "set_max_delay -datapath_only -from \[get_pins \[list $startPointPins\]\] -to \[get_pins $HD_LUT/I0\] $value"
##                incr count
##             }
##          } elseif {[llength $clockPins]} {
##             puts "Critical Warning: Found [llength $clockPins] clock pins \{$clockPins\} on source cells \{[lindex $startPointCells 0]\} of input pin $pin, but no clocks were defined. Ensure all required constraints have been defined. Try \"get_clocks -of \[get_pins [lindex $clockPins 0]\]\"" 
##          }
##       }
##       if {![string match $FH "stdout"]} {
##          flush $FH
##       }
##    }
##    puts "\tAdded $count input path segmentation constraints for $cell"
## 
## 
##    #Process output pins. Add set_logic_dc to prevent timing arc 
##    #from being disabled by a constant (LUT1 connected to GND).
##    set outputs [get_pins -of [get_cells $cell] -filter DIRECTION==OUT]
##    puts "\tProcessing Output Pins of cell $cell ([llength $outputs] pins)"
##    puts $FH "\n#Output pins:"
##    foreach pin [lsort -dict $outputs] {
##       set HD_LUT [get_cells -quiet -of [get_pins -quiet -leaf -filter NAME=~$cell/HD_PR* -of [get_nets -quiet -of [get_pins $pin]]]]
##       if {[llength $HD_LUT]} {
##          #Set a DC on LUT initially to prevent constant propagation, or no timing paths will be found, and all_fanout will return 0 endpoints
##          set_logic_dc  [get_pins $HD_LUT/I0]
##       }
##    }
## 
##    set count 0
##    foreach pin [lsort -dict $outputs] {
##       if {[lsearch -exact $excludePins [lindex [split $pin /] end]] > "-1"} {
##          puts "\tInfo: Skipping excluded pin $pin"
##          continue
##       }
##       set HD_LUT [get_cells -quiet -of [get_pins -quiet -leaf -filter NAME=~$cell/HD_PR* -of [get_nets -quiet -of [get_pins $pin]]]]
##       if {[llength $HD_LUT]} {
## ##         #Set a DC on LUT initially to prevent constant propagation, or no timing paths will be found, and all_fanout will return 0 endpoints
## ##         set_logic_dc  [get_pins $HD_LUT/I0]
##          #Get the cell names and filter out GTs, OBUF, etc.
##          set endPointCells [get_cells -quiet -filter $filter [all_fanout -quiet -endpoints_only -flat -only_cells $pin]]
##          set clockPins [get_pins -quiet -filter IS_CLOCK -of $endPointCells]
##          set clocks [get_clocks -quiet -of $clockPins]
##          if {[llength $clocks]} {
##             #Add set_logic_dc to XDC or set_max_delay on outputs wont't work. Only set once on pins with endpoints.
##             puts $FH "set_logic_dc \[get_pins $HD_LUT/I0\]"
##             foreach clock $clocks {
##                #set timingPaths [get_timing_paths -quiet -through $pin -to $endPointCells -max_paths 100000 -filter ENDPOINT_CLOCK==$clock]
##                set timingPaths [get_timing_paths -quiet -through $pin -to $endPointCells -nworst 100000 -filter ENDPOINT_CLOCK==$clock]
##                if {![llength $timingPaths]} {
##                    puts "\tCritical Warning: No timing path found through pin $pin for clock $clock." 
##                   continue
##                }
##                #set endPointPins [lsort -dict -unique [join [get_pins [get_property ENDPOINT_PIN $timingPaths] -filter $filter]]]
##                set endPointPins [lsort -dict -unique [get_pins [get_property ENDPOINT_PIN $timingPaths] -filter $filter]]
##                lappend endPoints [get_cells -of [get_pins $endPointPins]]
##                set logicLevels [lindex [lsort -dict [get_property LOGIC_LEVELS $timingPaths]] end]
##                set period [get_property PERIOD [get_clocks $clock]]
##                if {$logicLevels < 1} {
##                   set percentage "0.4"
##                } elseif {$logicLevels < 2} {
##                   set percentage "0.5"
##                } elseif {$logicLevels < 3} {
##                   set percentage "0.6"
##                } elseif {$logicLevels < 4} {
##                   set percentage "0.7"
##                } elseif {$logicLevels >= 4} {
##                   set percentage "0.8"
##                   #puts "\tCritical Warning: Path found with $logicLevels levels of logic through pin $pin. Consider revising interface."
##                   #puts "\tPath has load clock $clock with period of ${period}ns. Interface budget set to ${percentage} of period."
##                }
##                #puts "#DEBUG - Pin: $pin\nLoad Data Pin: $end\nLoad Clock Pin: $clock\nPeriod: $period"
##                set value [expr $period * $percentage]
##                puts $FH "#Pin: $pin\tLogic Levels: $logicLevels\tClock: $clock\tPeriod: $period\tBudget: $percentage"
##                puts $FH "set_max_delay -datapath_only -from \[get_pins $HD_LUT/O\] -to \[get_pins \[list $endPointPins\]\] $value"
##                incr count
##             }
##          } elseif {[llength $clockPins]} {
##             puts "Critical Warning: Found [llength $clockPins] clock pins \{$clockPins\} on load cells \{[lindex $endPointCells 0]\} of output pin $pin, but no clocks were defined. Ensure all required constraints have been defined. Try \"get_clocks -of \[get_pins [lindex $clockPins 0]\]\"" 
##          }
##       }
##       if {![string match $FH "stdout"]} {
##          flush $FH
##       }
##    }
##    puts "\tAdded $count output path segmentation constraints for $cell"
## 
## 
##    ###Check if feedback path exists... ie. startpoint also exists as an endpoint
## ##Comment this out as some designs have a high occurance of this (too many messages). 
## #   set startPoints [lsort -dict [join $startPoints]]
## #   set endPoints [lsort -dict [join $endPoints]]
## #   foreach point $startPoints {
## #      set matches [lsearch -exact -all $endPoints $point]
## #      if {[llength $matches] > 0} {
## #         puts "\nCritical Warning: The cell \'$point\' was found in more than one budget constraint. Constraining the same cell with multiple set_max_delay may lead to undesired timing results. \nResolution:\nSearch the resulting timing constraints for the cell listed above, and determine why this is being constrained through multiple Partition Pins.  Adjust the constraints or design as necessary."
## #      }
## #   }
## 
##    if {![string match $FH "stdout"]} {
##       close $FH
##    }
##    reset_msg_config -quiet -id "Constraints 18-514" -suppress
##    reset_msg_config -quiet -id "Constraints 18-515" -suppress
##    reset_msg_config -quiet -id "Constraints 18-402" -suppress
## }
## proc export_pblocks { args } {
## 
##    set FH "stdout"
##    set pblocks [get_pblocks]
## 
##    #Override defaults with command options
##    set argLength [llength $args]
##    set index 0
##    while {$index < $argLength} {
##       set arg [lindex $args $index]
##       set value [lindex $args [expr $index+1]]
##       switch -exact -- $arg {
##          {-pblocks}  {set pblocks [get_pblocks $value]}
##          {-file}     {set FH [open $value w]}
##          {-help}     {set     helpMsg "Description:"
##                       lappend helpMsg "Exports Pblocks from in memory design to STDOUT or specified file.\n"
##                       lappend helpMsg "Syntax:"
##                       lappend helpMsg "export_pblocks\t\[-pblocks <arg>] \[-file <arg>]\n"
##                       lappend helpMsg "Usage:"
##                       lappend helpMsg "  Name                        Description"
##                       lappend helpMsg "  ---------------------------------------"
##                       lappend helpMsg "  \[-pblocks]                  Optional. Specifies the list of Pblocks to export."
##                       lappend helpMsg "                              If no Pblocks are specified, all Pblocks will be exported." 
##                       lappend helpMsg "  \[-file]                    Optional. Specifies the output file name."
##                       lappend helpMsg "                               If not specified the output will be written to STDOUT"
##                       lappend helpMsg "  \[-help]                    Displays this message\n\n"
##                       foreach line $helpMsg {
##                          puts $line
##                       }
##                       return
##                      }
##          default     {set errMsg "ERROR: Specified argument $arg is not supported.\n"
##                       append errMsg "Supported arguments are -help, -pblocks, and -file.\n"
##                       append errMsg "Use the -help option for more details"
##                       error $errMsg 
##                      }
##       }
##       set index [expr $index + 2]
##    }
## 
##    foreach pblock $pblocks {
##       puts $FH "\n\n####Pblock $pblock####"
##       puts $FH "create_pblock $pblock"
##       set cells [get_cells -quiet -of [get_pblocks $pblock]]
##       if {[llength $cells]} {
##          puts $FH "add_cells_to_pblock \[get_pblocks $pblock\] \[get_cells \[list $cells\]\]"
##       }
##       set grids  [get_property GRIDTYPES [get_pblock $pblock]]
##       set ranges [get_property GRID_RANGES [get_pblocks $pblock]]
##       set matchedRanges ""
##       foreach grid $grids {
##          set grid_ranges ""
##          foreach range $ranges {
##             regexp {(\w+)_(X\d+Y\d+)} $range temp type value
##             if {[string match $grid $type]} {
##                lappend grid_ranges $range
##             }
##          }
##          if {[llength $grid_ranges]} {
##             puts $FH "resize_pblock \[get_pblocks $pblock\] -add \{$grid_ranges\}"
##             lappend matchedRanges $grid_ranges
##          } else {
##             puts "Critical Warning: Found GRIDTYPE $grid, but no ranges of the matching type in Pblock range for Pblock $pblock:\n$ranges"
##          }
##       }
## 
##       #Detect Ranges in Pblock with no matching GRIDTYPES (like BUFG or IO in non-PR Pblock)
##       foreach range $ranges {
##          if {[lsearch [join $matchedRanges] $range]==-1} {
##             puts $FH "resize_pblock \[get_pblocks $pblock\] -add \{$range\}"
##          }
##       }
## 
##       ##Check for addtitional Pblock properties
##       if {[get_property PARTPIN_SPREADING [get_pblocks $pblock]] != 5} {
##          puts $FH "set_property PARTPIN_SPREADING [get_property PARTPIN_SPREADING [get_pblocks $pblock]] \[get_pblocks $pblock\]"
##       }
##       if {[llength [get_property SNAPPING_MODE [get_pblocks $pblock]]]} {
##          puts $FH "set_property SNAPPING_MODE [get_property SNAPPING_MODE [get_pblocks $pblock]] \[get_pblocks $pblock\]"
##       }
##       if {[get_property CONTAIN_ROUTING [get_pblocks $pblock]]} {
##          puts $FH "set_property CONTAIN_ROUTING 1 \[get_pblocks $pblock\]"
##       }
##       if {[get_property EXCLUDE_PLACEMENT [get_pblocks $pblock]]} {
##          puts $FH "set_property EXCLUDE_PLACEMENT 1 \[get_pblocks $pblock\]"
##       }
##       if {[get_property RESET_AFTER_RECONFIG [get_pblocks $pblock]]} {
##          puts $FH "set_property RESET_AFTER_RECONFIG 1 \[get_pblocks $pblock\]"
##       }
##       if {![string match "ROOT" [get_property PARENT [get_pblocks $pblock]]]} {
##          puts $FH "set_property PARENT [get_property PARENT [get_pblocks $pblock]] \[get_pblocks $pblock\]"
##       }
##       flush $FH
##    }
##    if {![string match $FH "stdout"]} {
##       close $FH
##    }
## }
## proc mark_congestion { ranges } {
##    set colors {red green blue magenta yellow cyan orange}
##    set color 0
##    foreach range $ranges {
##       set intTile1 [lindex $range 0]
##       set intTile2 [lindex $range end]
## 
##       set corner1 [lindex [split $intTile1 _] end]
##       set corner2 [lindex [split $intTile2 _] end]
## 
##       set sites1 [get_sites -of [get_tiles *_$corner1]]
##       set sites2 [get_sites -of [get_tiles *_$corner2]]
##       puts "$corner1: $sites1"
##       puts "$corner2: $sites2"
## 
##       mark_objects -color [lindex $colors $color] [get_sites -range [lindex $sites1 0]:[lindex $sites2 end]]
##       if {$color==6} {
##          set color 0
##       } else {
##          incr color
##       }
##    }
## }
## proc get_overlapping_nodes {{limit 0}} {
##    set nets [get_nets -hier -filter ROUTE_STATUS==CONFLICTS]
##    puts "Found [llength $nets] nets with Conflicts."
##    set nodes [get_nodes -of $nets]
##    puts "Parsing [llength $nodes] nodes for potential overlaps."
##    set nodeOverlaps {}
##    set count 0
##    set lineCount 0
## 
##    puts -nonewline "0 "
##    foreach node $nodes {
##       #If a limit is specified, stop after #limit overlapping nodes are found
##       if {$limit > 0} {
##          if {[llength $nodeOverlaps] == $limit} {
##             break
##          }
##       }
##       set nodeNets [get_nets -quiet -of $node]
##       if {[llength $nodeNets] > 1} {
##          lappend nodeOverlaps $node
##       }
##       incr count
##       #Add a "." for every 100 nodes checked
##       if {[expr fmod($count,100)]==0.0} {
##          puts -nonewline "."
##       }
## 
##       #Add a new line of "."s for every 1000 nodes
##       if {$count == 1000} {
##          set count 0
##          incr lineCount
##          puts ""
##          puts -nonewline "${lineCount}k"
##       }
##    }
##    puts "\nFound [llength $nodeOverlaps] overlapping nodes."
##    if {[llength $nodeOverlaps]} {
##       select_objects $nodeOverlaps
##       highlight_objects -color red [get_selected_objects]
##    }
## }
# source $tclDir/pr_utils.tcl
## proc get_rps {} {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    set rps [get_cells -quiet -hier -filter HD.RECONFIGURABLE]
##    if {![llength $rps]} {
##       puts "Info: No cells found with HD.RECONFIGURABLE==1"
##       return
##    }
##    return $rps
## }
## proc toggle_pr { cells } {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    foreach cell $cells {
##       if {[get_property HD.RECONFIGURABLE [get_cells $cell]] != "1"} {
##          set_property HD.RECONFIGURABLE 1 [get_cells $cell]
##       } else {
##          set_property HD.RECONFIGURABLE 0 [get_cells $cell]
##       }
##    } 
## }
## proc get_pp_range { cell } {
##    set pp_range_sites ""
##    set pp_ranges ""
##    set pins [get_pins -filter HD.PARTPIN_RANGE!="" -of [get_cells $cell]]
##    foreach pin $pins {
##       set ranges [get_property HD.PARTPIN_RANGE [get_pins $pin]]
##       if {[llength $ranges]} {
##          foreach range $ranges {
##             if {[lsearch -exact $pp_ranges $range]==-1} {
##                puts "Found unique range $range"
##                lappend pp_ranges $range
##                lappend pp_range_sites [get_sites -range $range]
##             }
##          }
##       }
##    }
##    set sites [concat {*}$pp_range_sites]
##    highlight_objects -color yellow [get_sites [lsort $sites]]
## }
## proc export_partpins { args } {
##    set FH "stdout"
##    set pins [get_pins -hier * -filter HD.ASSIGNED_PPLOCS!=""]
## 
##    #Override defaults with command options
##    set argLength [llength $args]
##    set index 0
##    while {$index < $argLength} {
##       set arg [lindex $args $index]
##       set value [lindex $args [expr $index+1]]
##       switch -exact -- $arg {
##          {-cells}  {set cells [get_cells $value]}
##          {-file}     {set FH [open $value w]}
##          {-help}     {set     helpMsg "Description:"
##                       lappend helpMsg "Exports Partition Pins from in memory design to STDOUT or specified file.\n"
##                       lappend helpMsg "Syntax:"
##                       lappend helpMsg "export_partpins\t\[-cells <arg>] \[-file <arg>]\n"
##                       lappend helpMsg "Usage:"
##                       lappend helpMsg "  Name                        Description"
##                       lappend helpMsg "  ---------------------------------------"
##                       lappend helpMsg "  \[-cells]                  Optional. Specifies the list of Cells to export."
##                       lappend helpMsg "                              If no Cells are specified, all PartPins will be exported." 
##                       lappend helpMsg "  \[-file]                   Optional. Specifies the output file name."
##                       lappend helpMsg "                              If not specified the output will be written to STDOUT"
##                       lappend helpMsg "  \[-help]                   Displays this message\n\n"
##                       foreach line $helpMsg {
##                          puts $line
##                       }
##                       return
##                      }
##          default     {set errMsg "ERROR: Specified argument $arg is not supported.\n"
##                       append errMsg "Supported arguments are -help, -pblocks, and -file.\n"
##                       append errMsg "Use the -help option for more details"
##                       error $errMsg 
##                      }
##       }
##       set index [expr $index + 2]
##    }
##    
##    if {![info exists cells]} {
##       set errMsg "Error: No -cells option specificed. A cell must be specified with this option."
##       error $errMsg
##    }
## 
##    #if -cell is used, clear out pin list and create a list based of of specified cells
##    if {[llength $cells]} {
##       foreach cell $cells {
##          foreach pin [lsort -dict [get_pins -of [get_cells $cell] -filter HD.ASSIGNED_PPLOCS!=""]] {
##             puts $FH "set_property HD.PARTPIN_LOCS [lindex [get_property HD.ASSIGNED_PPLOCS $pin] 0] \[get_pins \{$pin\}\]"
##             flush $FH
##          }
##       }
##    }
##    close $FH
## }
## proc convert_pblocks {} {
## 
##    set filter "SNAPPING_MODE!=\"\" && SNAPPING_MODE!=OFF"
##    set pblocks [get_pblocks -filter $filter]
##    foreach pblock $pblocks {
##       resize_pblock $pblock -add [get_property DERIVED_RANGES $pblock] -replace
##    }
## }
## proc get_static_sites {} {
##    set sliceTotal [llength [get_sites SLICE*]]
##    set sliceExclude [llength [get_sites SLICE* -of [get_pblocks -filter EXCLUDE_PLACEMENT]]]
## 
##    puts "Total Slices: $sliceTotal"
##    puts "Slices Excluded: $sliceExclude"
##    puts "-----------------------------"
##    puts "Static Slices: [expr $sliceTotal - $sliceExclude]"
## }
## proc get_rp_clocks { cell {file ""}} {
##    set table " -row {\"Clock Pin\" \"Clock Net\" \"Clock Driver\" \"Driver Type\" \"RM Loads\" \"Static Loads\"}"
##    set count 0
##    set clockNets ""
##    set staticLods ""
##    set pins [get_pins $cell/* -filter DIRECTION==IN]
##    foreach pin $pins {
##       set clock_driver [get_cells -quiet -of [get_pins -quiet -leaf -of [get_nets -quiet -of $pin] -filter DIRECTION==OUT] -filter REF_NAME=~BUF*]
##       if {[llength $clock_driver]} {
##          incr count
##          set clock_net [get_nets -of [get_pins $pin]]
##          set driver_type [get_property REF_NAME [get_cells $clock_driver]]
##          set rm_loads [llength [get_pins -quiet -leaf -of $clock_net -filter NAME=~$cell/*]]
##          set static_pins [get_pins -quiet -leaf -of $clock_net -filter "NAME!~$cell/* && DIRECTION==IN"]
##          set static_loads [llength $static_pins]
##          append table " -row {$pin $clock_net $clock_driver $driver_type $rm_loads $static_loads}"
##          lappend clockNets $clock_net
##          lappend staticLoads [get_cells -quiet -of $static_pins -filter "REF_NAME!~BUF* && REF_NAME!~MMCM* && REF_NAME!~PLL*"]
##       }
##    }
##    set title "-title {#HD: Clock information for RP $cell ($count clocks total)}"
##    set table ${title}${table}
##    if {[llength $file]} {
##       print_table $table -file $file
##    } else {
##       print_table $table
##    }
##    return $clockNets
## #   return $staticLoads
## }
## proc get_limit_clocks {{limit 4}} {
##    set clocks [get_clocks -quiet]
##    puts "Found [llength $clocks] clocks in the design"
##    set clockCount 0
##    set title "-title {Total Clocks:[llength $clocks] in design. Reporting on clocks with $limit or less connections}"
##    set table " -row {\"\" \"Clock\" \"Total Loads\" \"Load Types\" \"Driver Type\"}"
##    foreach clock $clocks {
##       set loads  [get_pins -quiet -leaf -filter DIRECTION==IN -of [get_nets -of $clock]]
##       set driver [get_pins -quiet -leaf -filter DIRECTION==OUT -of [get_nets -of $clock]]
##       if {[llength $loads]<=$limit} {
##          incr clockCount
##          if {[llength $driver]} {
##             append table " -row {$clockCount $clock [llength $loads] [list [get_property REF_NAME $loads]] [get_property REF_NAME $driver]}"
##          } elseif {[llength [get_ports -quiet -of [get_nets -of $clock]]]} {
##             set driver [get_ports -of [get_nets -of $clock]]
##             append table " -row {$clockCount $clock [llength $loads] [list [get_property REF_NAME $loads]] Port\($driver\)}"
##          } else {
##             append table " -row {$clockCount $clock [llength $loads] [list [get_property REF_NAME $loads]] Unknown}"
##          }
##       }
##    }
##    print_table $table
## }
## proc highlight_internal_nets { cell {color red} } {
## 
##    if {[get_property IS_BLACKBOX [get_cells $cell]]} {
##       puts "Info: Cell $cell is a blackbox, and will not be processed."
##       return
##    }
##    #Get a list of all nets that match the cell name, but filter out clocks and Global_Logic
##    set nets [get_nets -hier -filter "NAME=~$cell/* && TYPE!=GLOBAL_CLOCK && TYPE!=GND && TYPE!=VCC && TYPE!= POWER && TYPE!=GROUND"]
##    puts "All nets from $cell: [llength $nets]"
##    set internal_nets ""
##    foreach net $nets {
##       #get a list of all leaf level pins that the net connects to
##       set pins [get_pins -quiet -leaf -of [get_nets $net]]
##       set external 0
##       #Look at each pin to see if connects to a pin outside of the specified cell
##       #If it does, ignore this net and move on (break)
##       foreach pin $pins {
##          if {![string match "$cell/*" $pin]} {
##             set external 1
##             break
##          }
##       }
##       if {!$external} {
##          lappend internal_nets $net
##       }
##    }
##    llength $internal_nets
##    puts "Internal nets of $cell: [llength $internal_nets]"
##    highlight_objects -color $color [get_nets $internal_nets]
## }
## proc get_common_nets { cells } {
##    array set netPins {}
##    foreach cell $cells {
##       set pins [lsort -dict [get_pins -of [get_cells $cell]]]
##       foreach pin $pins {
##          set net [get_nets -quiet -top -of $pin]
##          if {[llength $net]} {
##             lappend netPins($net) "${pin}([get_property DIRECTION $pin])"
##          }
##       }
##    }
##    #return [array get netPins]
##    set count 0
##    foreach net [lsort -dict [array names netPins]] {
##       set pins $netPins($net)
##       if {[llength $pins] > 1 && ![string match "<const*>" $net]} { 
##          incr count
##          puts "${net}([llength $pins]): [lsort -dict $pins]"
##       }
##    }
##    puts "Found $count nets with multiple PartPins"
## }
## proc rp_port_info { ports } {
## 
##    array set unique_ports {}
##    foreach port [lsort -dict $ports] {
##       set busName [get_property BUS_NAME $port]
##       set busWidth [get_property BUS_WIDTH $port] 
##       set direction [get_property DIRECTION $port]
##       if {[llength $busName]} {
##          set unique_ports($busName) "$busName $busWidth $direction"
##       } else {
##          set unique_ports($port) "$port 0 $direction"
##       }
##    }
## 
##    set table {-title RP Ports -row \{Port Width Direction\}}
##    foreach {port info} [lsort [array get unique_ports]] {
##       lassign $info name width direction
##       lappend table "-row \{$name $width $direction\}"
##    }
##    puts [join $table]
##    print_table [join $table]
## }
## proc pr_unlock {} {
##    lock_design -unlock -level routing
##    set_property IS_LOC_FIXED 0 [get_cells -hier -filter {(PRIMITIVE_LEVEL!=INTERNAL && PRIMITIVE_LEVEL!=MACRO && PRIMITIVE_LEVEL!="") && (REF_NAME=~FD* || REF_NAME=~LUT* || REF_NAME=~SRL* || REF_NAME=~CARRY* || REF_NAME=~MUX*)}]
##    set_property IS_BEL_FIXED 0 [get_cells -hier -filter {(PRIMITIVE_LEVEL!=INTERNAL && PRIMITIVE_LEVEL!=MACRO && PRIMITIVE_LEVEL!="") && (REF_NAME=~FD* || REF_NAME=~LUT* || REF_NAME=~SRL* || REF_NAME=~CARRY* || REF_NAME=~MUX*)}]
##    set_property IS_LOC_FIXED 0 [get_cells -hier -filter {(PRIMITIVE_LEVEL==MACRO) && (REF_NAME=~RAM* || REF_NAME=~LUT*)}]
##    set_property IS_BEL_FIXED 0 [get_cells -hier -filter {(PRIMITIVE_LEVEL==MACRO) && (REF_NAME=~RAM* || REF_NAME=~LUT*)}]
## }
## proc pr_unplace {} {
##    route_design -unroute
##    place_design -unplace
##    set cells [get_cells -quiet -hier -filter HD.RECONFIGURABLE]
##    foreach cell $cells {
##       reset_property HD.PARTPIN_LOCS [get_pins $cell/*]
##       reset_property HD.PARTPIN_RANGE [get_pins $cell/*]
##    }
## }
## proc reset_partpins {} {
##    set cells [get_cells -quiet -hier -filter HD.RECONFIGURABLE]
##    foreach cell $cells {
##       reset_property HD.PARTPIN_LOCS [get_pins $cell/*]
##       reset_property HD.PARTPIN_RANGE [get_pins $cell/*]
##    }
## }
# set xboard        "kc705"
# switch $xboard {
# vc707 {
#  set device       "xc7vx485t"
#  set package      "ffg1761"
#  set speed        "-2"
# }
# vc709 {
#  set device       "xc7vx690t"
#  set package      "ffg1761"
#  set speed        "-2"
# }
# default {
#  #kc705
#  set device       "xc7k325t"
#  set package      "ffg900"
#  set speed        "-1"
# }
# }
# set part         $device$package$speed
# check_part $part
INFO: Found part matching xc7k325tffg900-1
# set run.topSynth       1
# set run.rmSynth        1
# set run.prImpl         1
# set run.greyboxImpl    1
# set run.prVerify       1
# set run.writeBitstream 1
# set verbose      1
# set dcpLevel     1
# set synthDir  "./Synth"
# set implDir   "./Implement"
# set dcpDir    "./Checkpoint"
# set bitDir    "./Bitstreams"
# set srcDir     "./Sources"
# set rtlDir     "$srcDir/hdl"
# set ipDir      "$srcDir/ip"
# set prjDir     "$srcDir/prj"
# set xdcDir     "$srcDir/xdc"
# set coreDir    "$srcDir/cores"
# set netlistDir "$srcDir/netlist"
# set scriptDir  "$srcDir/scripts"
# set top "top"
# set static "Static"
# add_module $static
# set_attribute module $static moduleName    $top
# set_attribute module $static top_level     1
# set_attribute module $static vlog          [list $rtlDir/top/clocks.v   \
#                                                  $rtlDir/top/count_rp.v \
#                                                  $rtlDir/top/shift_rp.v \
#                                            ]
# set_attribute module $static vhdl          [list $rtlDir/top/debouncer.vhd work \
#                                                  $rtlDir/top/top.vhd       work \                               
#                                            ]
# set_attribute module $static ip            [list $ipDir/axi_emc_inst/axi_emc_inst.xci \
#                                                  $ipDir/prc/prc.xci \
#                                                  $ipDir/jtag_to_axi/jtag_to_axi.xci \
#                                                  $ipDir/ila_vs_count/ila_vs_count.xci \
#                                                  $ipDir/ila_vs_shift/ila_vs_shift.xci \
#                                                  $ipDir/ila_rom/ila_rom.xci \
#                                                  $ipDir/ila_axi_mem/ila_axi_mem.xci \
#                                                  $ipDir/ila_axi_reg/ila_axi_reg.xci \
#                                                  $ipDir/ila_icap/ila_icap.xci \
#                                            ]
# set_attribute module $static synthXDC      [list $xdcDir/${top}_$xboard.xdc]
# set_attribute module $static synth         ${run.topSynth}
# set module1 "shift"
# set module1_variant1 "shift_right"
# set variant $module1_variant1
# add_module $variant
# set_attribute module $variant moduleName   $module1
# set_attribute module $variant vlog         [list $rtlDir/$variant/$variant.v]
# set_attribute module $variant synth        ${run.rmSynth}
# set module1_variant2 "shift_left"
# set variant $module1_variant2
# add_module $variant
# set_attribute module $variant moduleName   $module1
# set_attribute module $variant vlog         [list $rtlDir/$variant/$variant.v]
# set_attribute module $variant synth        ${run.rmSynth}
# set module1_inst "inst_shift"
# set module2 "count"
# set module2_variant1 "count_up"
# set variant $module2_variant1
# add_module $variant
# set_attribute module $variant moduleName   $module2
# set_attribute module $variant vlog         [list $rtlDir/$variant/$variant.v]
# set_attribute module $variant synth        ${run.rmSynth}
# set module2_variant2 "count_down"
# set variant $module2_variant2
# add_module $variant
# set_attribute module $variant moduleName   $module2
# set_attribute module $variant vlog         [list $rtlDir/$variant/$variant.v]
# set_attribute module $variant synth        ${run.rmSynth}
# set module2_inst "inst_count"
# set config "Config_${module1_variant1}_${module2_variant1}" 
# add_implementation $config
# set_attribute impl $config top                 $top
# set_attribute impl $config implXDC             [list $xdcDir/${top}_$xboard.xdc]
# set_attribute impl $config partitions          [list [list $static           $top          implement] \
#                                                      [list $module1_variant1 $module1_inst implement] \
#                                                      [list $module2_variant1 $module2_inst implement] \
#                                                ]
# set_attribute impl $config pr.impl             1
# set_attribute impl $config impl                ${run.prImpl} 
# set_attribute impl $config verify              ${run.prVerify} 
# set_attribute impl $config bitstream           ${run.writeBitstream}
# set_attribute impl $config bitstream.pre       $scriptDir/update_prc_$xboard.tcl  
# if {$xboard == "vc709"} {
# set_attribute impl $config bitstream_settings  [list "BITSTREAM.STARTUP.STARTUPCLK      CCLK"    \
#                                                      "BITSTREAM.CONFIG.EXTMASTERCCLK_EN DISABLE" \
#                                                      "BITSTREAM.CONFIG.BPI_SYNC_MODE    DISABLE" \
#                                                      "BITSTREAM.CONFIG.PERSIST          NO"      \
#                                                      "BITSTREAM.GENERAL.COMPRESS        TRUE"   \
#                                                       ]
# } else {
# set_attribute impl $config bitstream_settings  [list "BITSTREAM.STARTUP.STARTUPCLK      CCLK"    \
#                                                      "BITSTREAM.CONFIG.EXTMASTERCCLK_EN DISABLE" \
#                                                      "BITSTREAM.CONFIG.BPI_SYNC_MODE    DISABLE" \
#                                                      "BITSTREAM.CONFIG.PERSIST          NO"      \
#                                                      "BITSTREAM.GENERAL.COMPRESS        FALSE"   \
#                                                       ]
# } 
# set_attribute impl $config partial_bitstream_settings [list "BITSTREAM.GENERAL.COMPRESS FALSE"   \
#                                                       ]
# set config "Config_${module1_variant2}_${module2_variant2}" 
# add_implementation $config
# set_attribute impl $config top                 $top
# set_attribute impl $config implXDC             [list $xdcDir/${top}_$xboard.xdc]
# set_attribute impl $config partitions          [list [list $static           $top          import]    \
#                                                      [list $module1_variant2 $module1_inst implement] \
#                                                      [list $module2_variant2 $module2_inst implement] \
#                                                ]
# set_attribute impl $config pr.impl             1
# set_attribute impl $config impl                ${run.prImpl} 
# set_attribute impl $config verify              ${run.prVerify} 
# set_attribute impl $config bitstream           ${run.writeBitstream} 
# if {$xboard == "vc709"} {
# set_attribute impl $config bitstream_settings  [list "BITSTREAM.STARTUP.STARTUPCLK      CCLK"    \
#                                                      "BITSTREAM.CONFIG.EXTMASTERCCLK_EN DISABLE" \
#                                                      "BITSTREAM.CONFIG.BPI_SYNC_MODE    DISABLE" \
#                                                      "BITSTREAM.CONFIG.PERSIST          NO"      \
#                                                      "BITSTREAM.GENERAL.COMPRESS        TRUE"   \
#                                                       ]
# } else {
# set_attribute impl $config bitstream_settings  [list "BITSTREAM.STARTUP.STARTUPCLK      CCLK"    \
#                                                      "BITSTREAM.CONFIG.EXTMASTERCCLK_EN DISABLE" \
#                                                      "BITSTREAM.CONFIG.BPI_SYNC_MODE    DISABLE" \
#                                                      "BITSTREAM.CONFIG.PERSIST          NO"      \
#                                                      "BITSTREAM.GENERAL.COMPRESS        FALSE"   \
#                                                       ]
# } 
# set_attribute impl $config partial_bitstream_settings [list "BITSTREAM.GENERAL.COMPRESS FALSE"   \
#                                                       ]
# set config "Config_greybox" 
# add_implementation $config
# set_attribute impl $config top                 $top
# set_attribute impl $config implXDC             [list $xdcDir/${top}_$xboard.xdc]
# set_attribute impl $config partitions          [list [list $static           $top          import ] \
#                                                      [list $module1_variant2 $module1_inst greybox] \
#                                                      [list $module2_variant2 $module2_inst greybox] \
#                                                ]
# set_attribute impl $config pr.impl             1
# set_attribute impl $config impl                ${run.greyboxImpl} 
# set_attribute impl $config verify              ${run.prVerify} 
# set_attribute impl $config bitstream           ${run.writeBitstream} 
# if {$xboard == "vc709"} {
# set_attribute impl $config bitstream_settings  [list "BITSTREAM.STARTUP.STARTUPCLK      CCLK"    \
#                                                      "BITSTREAM.CONFIG.EXTMASTERCCLK_EN DISABLE" \
#                                                      "BITSTREAM.CONFIG.BPI_SYNC_MODE    DISABLE" \
#                                                      "BITSTREAM.CONFIG.PERSIST          NO"      \
#                                                      "BITSTREAM.GENERAL.COMPRESS        TRUE"   \
#                                                       ]
# } else {
# set_attribute impl $config bitstream_settings  [list "BITSTREAM.STARTUP.STARTUPCLK      CCLK"    \
#                                                      "BITSTREAM.CONFIG.EXTMASTERCCLK_EN DISABLE" \
#                                                      "BITSTREAM.CONFIG.BPI_SYNC_MODE    DISABLE" \
#                                                      "BITSTREAM.CONFIG.PERSIST          NO"      \
#                                                      "BITSTREAM.GENERAL.COMPRESS        FALSE"   \
#                                                       ]
# } 
# set_attribute impl $config partial_bitstream_settings [list "BITSTREAM.GENERAL.COMPRESS FALSE"   \
#                                                       ]
# if {![file exists $ipDir/prc/prc.xci]} {
#    source $scriptDir/gen_ip_$xboard.tcl
# }
# source $tclDir/run.tcl
## list_runs

#HD: List of modules to be synthesized:
| ------------ | ------------ | ---------- | --------------------------- |
| Module       | Module Name  | Top Level  | Options                     |
| ------------ | ------------ | ---------- | --------------------------- |
| Static       | top          | 1          | -flatten_hierarchy rebuilt  |
| ------------ | ------------ | ---------- | --------------------------- |
| shift_right  | shift        | 0          | -flatten_hierarchy rebuilt  |
| ------------ | ------------ | ---------- | --------------------------- |
| shift_left   | shift        | 0          | -flatten_hierarchy rebuilt  |
| ------------ | ------------ | ---------- | --------------------------- |
| count_up     | count        | 0          | -flatten_hierarchy rebuilt  |
| ------------ | ------------ | ---------- | --------------------------- |
| count_down   | count        | 0          | -flatten_hierarchy rebuilt  |
| ------------ | ------------ | ---------- | --------------------------- |


#HD: List of Configurations to be implemented:
| ----------------------------- | ----------------------- | ------------- | ---------- | --------------- |
| Configuration                 | Reconfig Modules        | Static State  | pr_verify  | write_bistream  |
| ----------------------------- | ----------------------- | ------------- | ---------- | --------------- |
| Config_shift_right_count_up   | shift_right(implement)  | implement     | 1          | 1               |
| ----------------------------- | ----------------------- | ------------- | ---------- | --------------- |
|                               | count_up(implement)     |               |            |                 |
| ----------------------------- | ----------------------- | ------------- | ---------- | --------------- |
| Config_shift_left_count_down  | shift_left(implement)   | import        | 1          | 1               |
| ----------------------------- | ----------------------- | ------------- | ---------- | --------------- |
|                               | count_down(implement)   |               |            |                 |
| ----------------------------- | ----------------------- | ------------- | ---------- | --------------- |
| Config_greybox                | greybox                 | import        | 1          | 1               |
| ----------------------------- | ----------------------- | ------------- | ---------- | --------------- |
|                               | greybox                 |               |            |                 |
| ----------------------------- | ----------------------- | ------------- | ---------- | --------------- |



## foreach module [get_modules synth] {
##    synthesize $module
## }
#HD: Running synthesis for block Static
	Writing results to: ./Synth/Static
	#HD: Setting Tcl Params:
	hd.visual == 1
	hd.routingContainmentAreaExpansion == false


INFO: [IP_Flow 19-234] Refreshing IP repositories
INFO: [IP_Flow 19-1704] No user IP repositories specified
INFO: [IP_Flow 19-2313] Loaded Vivado IP repository '/opt/Xilinx/Vivado/2016.4/data/ip'.
	#HD: Adding 'xci' file axi_emc_inst.xci
	Generating output for IP axi_emc_inst
	#HD: Adding 'xci' file prc.xci
	#HD: Adding 'xci' file jtag_to_axi.xci
	#HD: Adding 'xci' file ila_vs_count.xci
	Generating output for IP ila_vs_count
	#HD: Adding 'xci' file ila_vs_shift.xci
	Generating output for IP ila_vs_shift
	#HD: Adding 'xci' file ila_rom.xci
	Generating output for IP ila_rom
	#HD: Adding 'xci' file ila_axi_mem.xci
	Generating output for IP ila_axi_mem
	#HD: Adding 'xci' file ila_axi_reg.xci
	Generating output for IP ila_axi_reg
	#HD: Adding 'xci' file ila_icap.xci
	Generating output for IP ila_icap
	#HD: Adding 'xdc' file ./Sources/xdc/top_kc705.xdc
	Running synth_design
Command: synth_design -mode default -flatten_hierarchy rebuilt -top top -part xc7k325tffg900-1
Starting synth_design
Attempting to get a license for feature 'Synthesis' and/or device 'xc7k325t'
WARNING: [Common 17-348] Failed to get the license for feature 'Synthesis' and/or device 'xc7k325t'
3 Infos, 1 Warnings, 0 Critical Warnings and 1 Errors encountered.
synth_design failed
#HD: Command 'synth_design' failed! Parsing ./Synth/Static/top_synth_design.rds for relavant messages
ERROR: [Common 17-345] A valid license was not found for feature 'Synthesis' and/or device 'xc7k325t'. Please run the Vivado License Manager for assistance in determining
which features and devices are licensed for your system.
Resolution: Check the status of your licenses in the Vivado License Manager. For debug help search Xilinx Support for "Licensing FAQ". 

ERROR: synth_design command "synth_design -mode default -flatten_hierarchy rebuilt -top top -part xc7k325tffg900-1" failed.
See log file ./Synth/Static/top_synth_design.rds for more details.
    while executing
"error $errMsg"
    invoked from within
"if { [catch "$command > $log" errMsg] && !$quiet } {
         puts "#HD: Command \'$commandName\' failed! Parsing $log for relavant messages"
        ..."
    invoked from within
"if {[llength $log] > 0} {
      if { [catch "$command > $log" errMsg] && !$quiet } {
         puts "#HD: Command \'$commandName\' failed! Parsing $log..."
    (procedure "command" line 41)
    invoked from within
"command "synth_design -mode default $options -top $moduleName -part $part" "$resultDir/${moduleName}_synth_design.rds""
    invoked from within
"if {$topLevel} {
      command "synth_design -mode default $options -top $moduleName -part $part" "$resultDir/${moduleName}_synth_design.rds"
   } els..."
    (procedure "synthesize" line 163)
    invoked from within
"synthesize $module"
    ("foreach" body line 2)
    invoked from within
"foreach module [get_modules synth] {
   synthesize $module
}"
    (file "./Tcl_HD/run.tcl" line 7)

    while executing
"source $tclDir/run.tcl"
    (file "design.tcl" line 271)
exit
INFO: [Common 17-206] Exiting Vivado at Wed Oct 24 11:00:08 2018...
